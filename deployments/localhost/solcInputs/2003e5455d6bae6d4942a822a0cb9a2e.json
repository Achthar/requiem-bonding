{
  "language": "Solidity",
  "sources": {
    "contracts/Authority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./interfaces/IAuthority.sol\";\n\nimport \"./libraries/types/AccessControlled.sol\";\n\ncontract Authority is IAuthority, AccessControlled {\n  /* ========== STATE VARIABLES ========== */\n\n  address public override governor;\n\n  address public override guardian;\n\n  address public override policy;\n\n  address public override vault;\n\n  address public newGovernor;\n\n  address public newGuardian;\n\n  address public newPolicy;\n\n  address public newVault;\n\n  /* ========== Constructor ========== */\n\n  constructor(\n    address _governor,\n    address _guardian,\n    address _policy,\n    address _vault\n  ) AccessControlled(IAuthority(address(this))) {\n    governor = _governor;\n    emit GovernorPushed(address(0), governor, true);\n    guardian = _guardian;\n    emit GuardianPushed(address(0), guardian, true);\n    policy = _policy;\n    emit PolicyPushed(address(0), policy, true);\n    vault = _vault;\n    emit VaultPushed(address(0), vault, true);\n  }\n\n  /* ========== GOV ONLY ========== */\n\n  function pushGovernor(address _newGovernor, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) governor = _newGovernor;\n    newGovernor = _newGovernor;\n    emit GovernorPushed(governor, newGovernor, _effectiveImmediately);\n  }\n\n  function pushGuardian(address _newGuardian, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) guardian = _newGuardian;\n    newGuardian = _newGuardian;\n    emit GuardianPushed(guardian, newGuardian, _effectiveImmediately);\n  }\n\n  function pushPolicy(address _newPolicy, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) policy = _newPolicy;\n    newPolicy = _newPolicy;\n    emit PolicyPushed(policy, newPolicy, _effectiveImmediately);\n  }\n\n  function pushVault(address _newVault, bool _effectiveImmediately)\n    external\n    onlyGovernor\n  {\n    if (_effectiveImmediately) vault = _newVault;\n    newVault = _newVault;\n    emit VaultPushed(vault, newVault, _effectiveImmediately);\n  }\n\n  /* ========== PENDING ROLE ONLY ========== */\n\n  function pullGovernor() external {\n    require(msg.sender == newGovernor, \"!newGovernor\");\n    emit GovernorPulled(governor, newGovernor);\n    governor = newGovernor;\n  }\n\n  function pullGuardian() external {\n    require(msg.sender == newGuardian, \"!newGuard\");\n    emit GuardianPulled(guardian, newGuardian);\n    guardian = newGuardian;\n  }\n\n  function pullPolicy() external {\n    require(msg.sender == newPolicy, \"!newPolicy\");\n    emit PolicyPulled(policy, newPolicy);\n    policy = newPolicy;\n  }\n\n  function pullVault() external {\n    require(msg.sender == newVault, \"!newVault\");\n    emit VaultPulled(vault, newVault);\n    vault = newVault;\n  }\n}\n"
    },
    "contracts/interfaces/IAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface IAuthority {\n    /* ========== EVENTS ========== */\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    /* ========== VIEW ========== */\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n"
    },
    "contracts/libraries/types/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\nimport \"../../interfaces/IAuthority.sol\";\n\nabstract contract AccessControlled {\n    /* ========== EVENTS ========== */\n\n    event AuthorityUpdated(IAuthority indexed authority);\n\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    /* ========== STATE VARIABLES ========== */\n\n    IAuthority public authority;\n\n    /* ========== Constructor ========== */\n\n    constructor(IAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyPolicy() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n\n    /* ========== GOV ONLY ========== */\n\n    function setAuthority(IAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.11;\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/IOwnable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./interfaces/IREQ.sol\";\nimport \"./interfaces/IsREQ.sol\";\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\nimport \"./libraries/types/AccessControlled.sol\";\n\ncontract Treasury is AccessControlled, ITreasury {\n  /* ========== DEPENDENCIES ========== */\n\n  using SafeERC20 for IERC20;\n\n  /* ========== EVENTS ========== */\n\n  event Deposit(address indexed token, uint256 amount, uint256 value);\n  event Withdrawal(address indexed token, uint256 amount, uint256 value);\n  event CreateDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event RepayDebt(\n    address indexed debtor,\n    address indexed token,\n    uint256 amount,\n    uint256 value\n  );\n  event Managed(address indexed token, uint256 amount);\n  event ReservesAudited(uint256 indexed totalReserves);\n  event Minted(\n    address indexed caller,\n    address indexed recipient,\n    uint256 amount\n  );\n  event PermissionQueued(STATUS indexed status, address queued);\n  event Permissioned(address addr, STATUS indexed status, bool result);\n\n  /* ========== DATA STRUCTURES ========== */\n\n  enum STATUS {\n    RESERVEDEPOSITOR,\n    RESERVESPENDER,\n    RESERVETOKEN,\n    RESERVEMANAGER,\n    LIQUIDITYDEPOSITOR,\n    LIQUIDITYTOKEN,\n    LIQUIDITYMANAGER,\n    RESERVEDEBTOR,\n    REWARDMANAGER,\n    SREQ,\n    REQDEBTOR\n  }\n\n  struct Queue {\n    STATUS managing;\n    address toPermit;\n    address calculator;\n    uint256 timelockEnd;\n    bool nullify;\n    bool executed;\n  }\n\n  /* ========== STATE VARIABLES ========== */\n\n  IREQ public immutable REQ;\n  IsREQ public sREQ;\n\n  mapping(STATUS => address[]) public registry;\n  mapping(STATUS => mapping(address => bool)) public permissions;\n  mapping(address => address) public bondCalculator;\n\n  mapping(address => uint256) public debtLimit;\n\n  uint256 public totalReserves;\n  uint256 public totalDebt;\n  uint256 public reqDebt;\n\n  Queue[] public permissionQueue;\n  uint256 public immutable blocksNeededForQueue;\n\n  bool public timelockEnabled;\n  bool public initialized;\n\n  uint256 public onChainGovernanceTimelock;\n\n  string internal notAccepted = \"Treasury: not accepted\";\n  string internal notApproved = \"Treasury: not approved\";\n  string internal invalidToken = \"Treasury: invalid token\";\n  string internal insufficientReserves = \"Treasury: insufficient reserves\";\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    address _req,\n    uint256 _timelock,\n    address _authority\n  ) AccessControlled(IAuthority(_authority)) {\n    require(_req != address(0), \"Zero address: REQ\");\n    REQ = IREQ(_req);\n\n    timelockEnabled = false;\n    initialized = false;\n    blocksNeededForQueue = _timelock;\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /**\n   * @notice allow approved address to deposit an asset for REQ\n   * @param _amount uint256\n   * @param _token address\n   * @param _profit uint256\n   * @return send_ uint256\n   */\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external override returns (uint256 send_) {\n    if (permissions[STATUS.RESERVETOKEN][_token]) {\n      require(permissions[STATUS.RESERVEDEPOSITOR][msg.sender], notApproved);\n    } else if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\n      require(permissions[STATUS.LIQUIDITYDEPOSITOR][msg.sender], notApproved);\n    } else {\n      revert(invalidToken);\n    }\n\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint256 value = tokenValue(_token, _amount);\n    // mint REQ needed and store amount of rewards for distribution\n    send_ = value - _profit;\n    REQ.mint(msg.sender, send_);\n\n    totalReserves += value;\n\n    emit Deposit(_token, _amount, value);\n  }\n\n  /**\n   * @notice allow approved address to burn REQ for reserves\n   * @param _amount uint256\n   * @param _token address\n   */\n  function withdraw(uint256 _amount, address _token) external override {\n    require(permissions[STATUS.RESERVETOKEN][_token], notAccepted); // Only reserves can be used for redemptions\n    require(permissions[STATUS.RESERVESPENDER][msg.sender], notApproved);\n\n    uint256 value = tokenValue(_token, _amount);\n    REQ.burnFrom(msg.sender, value);\n\n    totalReserves -= value;\n\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n\n    emit Withdrawal(_token, _amount, value);\n  }\n\n  /**\n   * @notice allow approved address to withdraw assets\n   * @param _token address\n   * @param _amount uint256\n   */\n  function manage(address _token, uint256 _amount) external override {\n    if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\n      require(permissions[STATUS.LIQUIDITYMANAGER][msg.sender], notApproved);\n    } else {\n      require(permissions[STATUS.RESERVEMANAGER][msg.sender], notApproved);\n    }\n    if (\n      permissions[STATUS.RESERVETOKEN][_token] ||\n      permissions[STATUS.LIQUIDITYTOKEN][_token]\n    ) {\n      uint256 value = tokenValue(_token, _amount);\n      require(value <= excessReserves(), insufficientReserves);\n      totalReserves -= value;\n    }\n    IERC20(_token).safeTransfer(msg.sender, _amount);\n    emit Managed(_token, _amount);\n  }\n\n  /**\n   * @notice mint new REQ using excess reserves\n   * @param _recipient address\n   * @param _amount uint256\n   */\n  function mint(address _recipient, uint256 _amount) external override {\n    require(permissions[STATUS.REWARDMANAGER][msg.sender], notApproved);\n    require(_amount <= excessReserves(), insufficientReserves);\n    REQ.mint(_recipient, _amount);\n    emit Minted(msg.sender, _recipient, _amount);\n  }\n\n  /**\n   * DEBT: The debt functions allow approved addresses to borrow treasury assets\n   * or REQ from the treasury, using sREQ as collateral. This might allow an\n   * sREQ holder to provide REQ liquidity without taking on the opportunity cost\n   * of unstaking, or alter their backing without imposing risk onto the treasury.\n   * Many of these use cases are yet to be defined, but they appear promising.\n   * However, we urge the community to think critically and move slowly upon\n   * proposals to acquire these permissions.\n   */\n\n  /**\n   * @notice allow approved address to borrow reserves\n   * @param _amount uint256\n   * @param _token address\n   */\n  function incurDebt(uint256 _amount, address _token) external override {\n    uint256 value;\n    if (_token == address(REQ)) {\n      require(permissions[STATUS.REQDEBTOR][msg.sender], notApproved);\n      value = _amount;\n    } else {\n      require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\n      require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\n      value = tokenValue(_token, _amount);\n    }\n    require(value != 0, invalidToken);\n\n    sREQ.changeDebt(value, msg.sender, true);\n    require(\n      sREQ.debtBalances(msg.sender) <= debtLimit[msg.sender],\n      \"Treasury: exceeds limit\"\n    );\n    totalDebt += value;\n\n    if (_token == address(REQ)) {\n      REQ.mint(msg.sender, value);\n      reqDebt += value;\n    } else {\n      totalReserves -= value;\n      IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n    emit CreateDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n   * @notice allow approved address to repay borrowed reserves with reserves\n   * @param _amount uint256\n   * @param _token address\n   */\n  function repayDebtWithReserve(uint256 _amount, address _token)\n    external\n    override\n  {\n    require(permissions[STATUS.RESERVEDEBTOR][msg.sender], notApproved);\n    require(permissions[STATUS.RESERVETOKEN][_token], notAccepted);\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n    uint256 value = tokenValue(_token, _amount);\n    sREQ.changeDebt(value, msg.sender, false);\n    totalDebt -= value;\n    totalReserves += value;\n    emit RepayDebt(msg.sender, _token, _amount, value);\n  }\n\n  /**\n   * @notice allow approved address to repay borrowed reserves with REQ\n   * @param _amount uint256\n   */\n  function repayDebtWithREQ(uint256 _amount) external {\n    require(\n      permissions[STATUS.RESERVEDEBTOR][msg.sender] ||\n        permissions[STATUS.REQDEBTOR][msg.sender],\n      notApproved\n    );\n    REQ.burnFrom(msg.sender, _amount);\n    sREQ.changeDebt(_amount, msg.sender, false);\n    totalDebt -= _amount;\n    reqDebt -= _amount;\n    emit RepayDebt(msg.sender, address(REQ), _amount, _amount);\n  }\n\n  /* ========== MANAGERIAL FUNCTIONS ========== */\n\n  /**\n   * @notice takes inventory of all tracked assets\n   * @notice always consolidate to recognized reserves before audit\n   */\n  function auditReserves() external onlyGovernor {\n    uint256 reserves;\n    address[] memory reserveToken = registry[STATUS.RESERVETOKEN];\n    for (uint256 i = 0; i < reserveToken.length; i++) {\n      if (permissions[STATUS.RESERVETOKEN][reserveToken[i]]) {\n        reserves += tokenValue(\n          reserveToken[i],\n          IERC20(reserveToken[i]).balanceOf(address(this))\n        );\n      }\n    }\n    address[] memory liquidityToken = registry[STATUS.LIQUIDITYTOKEN];\n    for (uint256 i = 0; i < liquidityToken.length; i++) {\n      if (permissions[STATUS.LIQUIDITYTOKEN][liquidityToken[i]]) {\n        reserves += tokenValue(\n          liquidityToken[i],\n          IERC20(liquidityToken[i]).balanceOf(address(this))\n        );\n      }\n    }\n    totalReserves = reserves;\n    emit ReservesAudited(reserves);\n  }\n\n  /**\n   * @notice set max debt for address\n   * @param _address address\n   * @param _limit uint256\n   */\n  function setDebtLimit(address _address, uint256 _limit)\n    external\n    onlyGovernor\n  {\n    debtLimit[_address] = _limit;\n  }\n\n  /**\n   * @notice enable permission from queue\n   * @param _status STATUS\n   * @param _address address\n   * @param _calculator address\n   */\n  function enable(\n    STATUS _status,\n    address _address,\n    address _calculator\n  ) external onlyGovernor {\n    require(timelockEnabled == false, \"Use queueTimelock\");\n    if (_status == STATUS.SREQ) {\n      sREQ = IsREQ(_address);\n    } else {\n      permissions[_status][_address] = true;\n\n      if (_status == STATUS.LIQUIDITYTOKEN) {\n        bondCalculator[_address] = _calculator;\n      }\n\n      (bool registered, ) = indexInRegistry(_address, _status);\n      if (!registered) {\n        registry[_status].push(_address);\n\n        if (\n          _status == STATUS.LIQUIDITYTOKEN || _status == STATUS.RESERVETOKEN\n        ) {\n          (bool reg, uint256 index) = indexInRegistry(_address, _status);\n          if (reg) {\n            delete registry[_status][index];\n          }\n        }\n      }\n    }\n    emit Permissioned(_address, _status, true);\n  }\n\n  /**\n   *  @notice disable permission from address\n   *  @param _status STATUS\n   *  @param _toDisable address\n   */\n  function disable(STATUS _status, address _toDisable) external {\n    require(\n      msg.sender == authority.governor() || msg.sender == authority.guardian(),\n      \"Only governor or guardian\"\n    );\n    permissions[_status][_toDisable] = false;\n    emit Permissioned(_toDisable, _status, false);\n  }\n\n  /**\n   * @notice check if registry contains address\n   * @return (bool, uint256)\n   */\n  function indexInRegistry(address _address, STATUS _status)\n    public\n    view\n    returns (bool, uint256)\n  {\n    address[] memory entries = registry[_status];\n    for (uint256 i = 0; i < entries.length; i++) {\n      if (_address == entries[i]) {\n        return (true, i);\n      }\n    }\n    return (false, 0);\n  }\n\n  /* ========== TIMELOCKED FUNCTIONS ========== */\n\n  // functions are used prior to enabling on-chain governance\n\n  /**\n   * @notice queue address to receive permission\n   * @param _status STATUS\n   * @param _address address\n   * @param _calculator address\n   */\n  function queueTimelock(\n    STATUS _status,\n    address _address,\n    address _calculator\n  ) external onlyGovernor {\n    require(_address != address(0));\n    require(timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n    uint256 timelock = block.number + blocksNeededForQueue;\n    if (\n      _status == STATUS.RESERVEMANAGER || _status == STATUS.LIQUIDITYMANAGER\n    ) {\n      timelock = block.number + blocksNeededForQueue * 2;\n    }\n    permissionQueue.push(\n      Queue({\n        managing: _status,\n        toPermit: _address,\n        calculator: _calculator,\n        timelockEnd: timelock,\n        nullify: false,\n        executed: false\n      })\n    );\n    emit PermissionQueued(_status, _address);\n  }\n\n  /**\n   *  @notice enable queued permission\n   *  @param _index uint256\n   */\n  function execute(uint256 _index) external {\n    require(timelockEnabled == true, \"Timelock is disabled, use enable\");\n\n    Queue memory info = permissionQueue[_index];\n\n    require(!info.nullify, \"Action has been nullified\");\n    require(!info.executed, \"Action has already been executed\");\n    require(block.number >= info.timelockEnd, \"Timelock not complete\");\n\n    if (info.managing == STATUS.SREQ) {\n      // 9\n      sREQ = IsREQ(info.toPermit);\n    } else {\n      permissions[info.managing][info.toPermit] = true;\n\n      if (info.managing == STATUS.LIQUIDITYTOKEN) {\n        bondCalculator[info.toPermit] = info.calculator;\n      }\n      (bool registered, ) = indexInRegistry(info.toPermit, info.managing);\n      if (!registered) {\n        registry[info.managing].push(info.toPermit);\n\n        if (info.managing == STATUS.LIQUIDITYTOKEN) {\n          (bool reg, uint256 index) = indexInRegistry(\n            info.toPermit,\n            STATUS.RESERVETOKEN\n          );\n          if (reg) {\n            delete registry[STATUS.RESERVETOKEN][index];\n          }\n        } else if (info.managing == STATUS.RESERVETOKEN) {\n          (bool reg, uint256 index) = indexInRegistry(\n            info.toPermit,\n            STATUS.LIQUIDITYTOKEN\n          );\n          if (reg) {\n            delete registry[STATUS.LIQUIDITYTOKEN][index];\n          }\n        }\n      }\n    }\n    permissionQueue[_index].executed = true;\n    emit Permissioned(info.toPermit, info.managing, true);\n  }\n\n  /**\n   * @notice cancel timelocked action\n   * @param _index uint256\n   */\n  function nullify(uint256 _index) external onlyGovernor {\n    permissionQueue[_index].nullify = true;\n  }\n\n  /**\n   * @notice disables timelocked functions\n   */\n  function disableTimelock() external onlyGovernor {\n    require(timelockEnabled == true, \"timelock already disabled\");\n    if (\n      onChainGovernanceTimelock != 0 &&\n      onChainGovernanceTimelock <= block.number\n    ) {\n      timelockEnabled = false;\n    } else {\n      onChainGovernanceTimelock = block.number + blocksNeededForQueue * 7; // 7-day timelock\n    }\n  }\n\n  /**\n   * @notice enables timelocks after initilization\n   */\n  function initialize() external onlyGovernor {\n    require(initialized == false, \"Already initialized\");\n    timelockEnabled = true;\n    initialized = true;\n  }\n\n  /* ========== VIEW FUNCTIONS ========== */\n\n  /**\n   * @notice returns excess reserves not backing tokens\n   * @return uint\n   */\n  function excessReserves() public view override returns (uint256) {\n    return totalReserves - (REQ.totalSupply() - totalDebt);\n  }\n\n  /**\n   * @notice returns REQ valuation of asset\n   * @param _token address\n   * @param _amount uint256\n   * @return value_ uint256\n   */\n  function tokenValue(address _token, uint256 _amount)\n    public\n    view\n    override\n    returns (uint256 value_)\n  {\n    value_ =\n      (_amount * (10**IERC20Metadata(address(REQ)).decimals())) /\n      (10**IERC20Metadata(_token).decimals());\n\n    if (permissions[STATUS.LIQUIDITYTOKEN][_token]) {\n      value_ = IBondingCalculator(bondCalculator[_token]).valuation(\n        _token,\n        _amount\n      );\n    }\n  }\n\n  /**\n   * @notice returns supply metric that cannot be manipulated by debt\n   * @dev use this any time you need to query supply\n   * @return uint256\n   */\n  function baseSupply() external view override returns (uint256) {\n    return REQ.totalSupply() - reqDebt;\n  }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Based on the ReentrancyGuard library from OpenZeppelin Contracts, altered to reduce gas costs.\n// The `safeTransfer` and `safeTransferFrom` functions assume that `token` is a contract (an account with code), and\n// work differently from the OpenZeppelin version if it is not.\n\npragma solidity ^0.8.11;\n\nimport \"./helpers/RequiemErrors.sol\";\n\nimport \"../interfaces/ERC20/IERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      address(token),\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   *\n   * WARNING: `token` is assumed to be a contract: calls to EOAs will *not* revert.\n   */\n  function _callOptionalReturn(address token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves.\n    (bool success, bytes memory returndata) = token.call(data);\n\n    // If the low-level call didn't succeed we return whatever was returned from it.\n    assembly {\n      if eq(success, 0) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n\n    // Finally we check the returndata size is either zero or true - note that this check will always pass for EOAs\n    RequiemErrors._require(\n      returndata.length == 0 || abi.decode(returndata, (bool)),\n      Errors.SAFE_ERC20_CALL_FAILED\n    );\n  }\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IOwnable {\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n  \n  function transferOwnership( address newOwner_ ) external;\n}"
    },
    "contracts/interfaces/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IERC20 {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/interfaces/ERC20/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "contracts/interfaces/IREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IREQ is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n"
    },
    "contracts/interfaces/IsREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.5;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IsREQ is IERC20 {\n    function rebase(uint256 reqProfit_, uint256 epoch_) external returns (uint256);\n\n    function circulatingSupply() external view returns (uint256);\n\n    function gonsForBalance(uint256 amount) external view returns (uint256);\n\n    function balanceForGons(uint256 gons) external view returns (uint256);\n\n    function index() external view returns (uint256);\n\n    function toG(uint256 amount) external view returns (uint256);\n\n    function fromG(uint256 amount) external view returns (uint256);\n\n    function changeDebt(\n        uint256 amount,\n        address debtor,\n        bool add\n    ) external;\n\n    function debtBalances(address _address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IBondingCalculator {\n  function valuation(address pair_, uint256 amount_)\n    external\n    view\n    returns (uint256 _value);\n}\n"
    },
    "contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\ninterface ITreasury {\n    function deposit(\n        uint256 _amount,\n        address _token,\n        uint256 _profit\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount, address _token) external;\n\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\n\n    function mint(address _recipient, uint256 _amount) external;\n\n    function manage(address _token, uint256 _amount) external;\n\n    function incurDebt(uint256 amount_, address token_) external;\n\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\n\n    function excessReserves() external view returns (uint256);\n\n    function baseSupply() external view returns (uint256);\n}\n"
    },
    "contracts/libraries/helpers/RequiemErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.11;\n\n// solhint-disable\nlibrary RequiemErrors {\n    /**\n     * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n     * supported.\n     */\n    function _require(bool condition, uint256 errorCode) internal pure {\n        if (!condition) RequiemErrors._revert(errorCode);\n    }\n\n    /**\n     * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n     */\n    function _revert(uint256 errorCode) internal pure {\n        // We're going to dynamically create a revert string based on the error code, with the following format:\n        // 'REQ#{errorCode}'\n        // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n        //\n        // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n        // number (8 to 16 bits) than the individual string characters.\n        //\n        // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n        // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n        // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n        assembly {\n            // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n            // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n            // the '0' character.\n\n            let units := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let tenths := add(mod(errorCode, 10), 0x30)\n\n            errorCode := div(errorCode, 10)\n            let hundreds := add(mod(errorCode, 10), 0x30)\n\n            // With the individual characters, we can now construct the full string. The \"REQ#\" part is a known constant\n            // (0x52455123): we simply shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n            // characters to it, each shifted by a multiple of 8.\n            // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n            // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n            // array).\n\n            let revertReason := shl(200, add(0x52455123000000, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n            // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n            // message will have the following layout:\n            // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n            // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n            // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n            mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n            // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n            mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n            // The string length is fixed: 7 characters.\n            mstore(0x24, 7)\n            // Finally, the string itself is stored.\n            mstore(0x44, revertReason)\n\n            // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n            // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n            revert(0, 100)\n        }\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n}\n"
    },
    "contracts/StakingDistributor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.11;\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IDistributor.sol\";\n\nimport \"./libraries/types/AccessControlled.sol\";\n\ncontract Distributor is IDistributor, AccessControlled {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeERC20 for IERC20;\n\n    /* ====== VARIABLES ====== */\n\n    IERC20 private immutable req;\n    ITreasury private immutable treasury;\n    address private immutable staking;\n\n    mapping(uint256 => Adjust) public adjustments;\n    uint256 public override bounty;\n\n    uint256 private immutable rateDenominator = 1_000_000;\n\n    /* ====== STRUCTS ====== */\n\n    struct Info {\n        uint256 rate; // in ten-thousandths ( 5000 = 0.5% )\n        address recipient;\n    }\n    Info[] public info;\n\n    struct Adjust {\n        bool add;\n        uint256 rate;\n        uint256 target;\n    }\n\n    /* ====== CONSTRUCTOR ====== */\n\n    constructor(\n        address _treasury,\n        address _req,\n        address _staking,\n        address _authority\n    ) AccessControlled(IAuthority(_authority)) {\n        require(_treasury != address(0), \"Zero address: Treasury\");\n        treasury = ITreasury(_treasury);\n        require(_req != address(0), \"Zero address: REQ\");\n        req = IERC20(_req);\n        require(_staking != address(0), \"Zero address: Staking\");\n        staking = _staking;\n    }\n\n    /* ====== PUBLIC FUNCTIONS ====== */\n\n    /**\n        @notice send epoch reward to staking contract\n     */\n    function distribute() external override {\n        require(msg.sender == staking, \"Only staking\");\n        // distribute rewards to each recipient\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].rate > 0) {\n                treasury.mint(info[i].recipient, nextRewardAt(info[i].rate)); // mint and send tokens\n                adjust(i); // check for adjustment\n            }\n        }\n    }\n\n    function retrieveBounty() external override returns (uint256) {\n        require(msg.sender == staking, \"Only staking\");\n        // If the distributor bounty is > 0, mint it for the staking contract.\n        if (bounty > 0) {\n            treasury.mint(address(staking), bounty);\n        }\n\n        return bounty;\n    }\n\n    /* ====== INTERNAL FUNCTIONS ====== */\n\n    /**\n        @notice increment reward rate for collector\n     */\n    function adjust(uint256 _index) internal {\n        Adjust memory adjustment = adjustments[_index];\n        if (adjustment.rate != 0) {\n            if (adjustment.add) {\n                // if rate should increase\n                info[_index].rate += adjustment.rate; // raise rate\n                if (info[_index].rate >= adjustment.target) {\n                    // if target met\n                    adjustments[_index].rate = 0; // turn off adjustment\n                    info[_index].rate = adjustment.target; // set to target\n                }\n            } else {\n                // if rate should decrease\n                if (info[_index].rate > adjustment.rate) {\n                    // protect from underflow\n                    info[_index].rate -= adjustment.rate; // lower rate\n                } else {\n                    info[_index].rate = 0;\n                }\n\n                if (info[_index].rate <= adjustment.target) {\n                    // if target met\n                    adjustments[_index].rate = 0; // turn off adjustment\n                    info[_index].rate = adjustment.target; // set to target\n                }\n            }\n        }\n    }\n\n    /* ====== VIEW FUNCTIONS ====== */\n\n    /**\n        @notice view function for next reward at given rate\n        @param _rate uint\n        @return uint\n     */\n    function nextRewardAt(uint256 _rate) public view override returns (uint256) {\n        return req.totalSupply() * _rate / rateDenominator;\n    }\n\n    /**\n        @notice view function for next reward for specified address\n        @param _recipient address\n        @return uint\n     */\n    function nextRewardFor(address _recipient) public view override returns (uint256) {\n        uint256 reward;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].recipient == _recipient) {\n                reward += nextRewardAt(info[i].rate);\n            }\n        }\n        return reward;\n    }\n\n    /* ====== POLICY FUNCTIONS ====== */\n\n    /**\n     * @notice set bounty to incentivize keepers\n     * @param _bounty uint256\n     */\n    function setBounty(uint256 _bounty) external override onlyGovernor {\n        require(_bounty <= 2e9, \"Too much\");\n        bounty = _bounty;\n    }\n\n    /**\n        @notice adds recipient for distributions\n        @param _recipient address\n        @param _rewardRate uint\n     */\n    function addRecipient(address _recipient, uint256 _rewardRate) external override onlyGovernor {\n        require(_recipient != address(0), \"Zero address: Recipient\");\n        require(_rewardRate <= rateDenominator, \"Rate cannot exceed denominator\");\n        info.push(Info({recipient: _recipient, rate: _rewardRate}));\n    }\n\n    /**\n        @notice removes recipient for distributions\n        @param _index uint\n     */\n    function removeRecipient(uint256 _index) external override {\n        require(\n            msg.sender == authority.governor() || msg.sender == authority.guardian(),\n            \"Caller is not governor or guardian\"\n        );\n        require(info[_index].recipient != address(0), \"Recipient does not exist\");\n        info[_index].recipient = address(0);\n        info[_index].rate = 0;\n    }\n\n    /**\n        @notice set adjustment info for a collector's reward rate\n        @param _index uint\n        @param _add bool\n        @param _rate uint\n        @param _target uint\n     */\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external override {\n        require(\n            msg.sender == authority.governor() || msg.sender == authority.guardian(),\n            \"Caller is not governor or guardian\"\n        );\n        require(info[_index].recipient != address(0), \"Recipient does not exist\");\n\n        if (msg.sender == authority.guardian()) {\n            require(_rate <= info[_index].rate * 25 / 1000, \"Limiter: cannot adjust by >2.5%\");\n        }\n\n        if (!_add) {\n            require(_rate <= info[_index].rate, \"Cannot decrease rate by more than it already is\");\n        }\n\n        adjustments[_index] = Adjust({add: _add, rate: _rate, target: _target});\n    }\n}\n"
    },
    "contracts/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IDistributor {\n    function distribute() external;\n\n    function bounty() external view returns (uint256);\n\n    function retrieveBounty() external returns (uint256);\n\n    function nextRewardAt(uint256 _rate) external view returns (uint256);\n\n    function nextRewardFor(address _recipient) external view returns (uint256);\n\n    function setBounty(uint256 _bounty) external;\n\n    function addRecipient(address _recipient, uint256 _rewardRate) external;\n\n    function removeRecipient(uint256 _index) external;\n\n    function setAdjustment(\n        uint256 _index,\n        bool _add,\n        uint256 _rate,\n        uint256 _target\n    ) external;\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.11;\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IsREQ.sol\";\nimport \"./interfaces/IgREQ.sol\";\nimport \"./interfaces/IDistributor.sol\";\n\nimport \"./libraries/types/AccessControlled.sol\";\n\ncontract Staking is AccessControlled {\n    /* ========== DEPENDENCIES ========== */\n\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IsREQ;\n    using SafeERC20 for IgREQ;\n\n    /* ========== EVENTS ========== */\n\n    event DistributorSet(address distributor);\n    event WarmupSet(uint256 warmup);\n\n    /* ========== DATA STRUCTURES ========== */\n\n    struct Epoch {\n        uint256 length; // in seconds\n        uint256 number; // since inception\n        uint256 end; // timestamp\n        uint256 distribute; // amount\n    }\n\n    struct Claim {\n        uint256 deposit; // if forfeiting\n        uint256 gons; // staked balance\n        uint256 expiry; // end of warmup period\n        bool lock; // prevents malicious delays for claim\n    }\n\n    /* ========== STATE VARIABLES ========== */\n\n    IERC20 public immutable REQ;\n    IsREQ public immutable sREQ;\n    IgREQ public immutable gREQ;\n\n    Epoch public epoch;\n\n    IDistributor public distributor;\n\n    mapping(address => Claim) public warmupInfo;\n    uint256 public warmupPeriod;\n    uint256 private gonsInWarmup;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _req,\n        address _sREQ,\n        address _gREQ,\n        uint256 _epochLength,\n        uint256 _firstEpochNumber,\n        uint256 _firstEpochTime,\n        address _authority\n    ) AccessControlled(IAuthority(_authority)) {\n        require(_req != address(0), \"Zero address: REQ\");\n        REQ = IERC20(_req);\n        require(_sREQ != address(0), \"Zero address: sREQ\");\n        sREQ = IsREQ(_sREQ);\n        require(_gREQ != address(0), \"Zero address: gREQ\");\n        gREQ = IgREQ(_gREQ);\n\n        epoch = Epoch({length: _epochLength, number: _firstEpochNumber, end: _firstEpochTime, distribute: 0});\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice stake REQ to enter warmup\n     * @param _to address\n     * @param _amount uint\n     * @param _claim bool\n     * @param _rebasing bool\n     * @return uint\n     */\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256) {\n        REQ.safeTransferFrom(msg.sender, address(this), _amount);\n        _amount += rebase(); // add bounty if rebase occurred\n        if (_claim && warmupPeriod == 0) {\n            return _send(_to, _amount, _rebasing);\n        } else {\n            Claim memory info = warmupInfo[_to];\n            if (!info.lock) {\n                require(_to == msg.sender, \"External deposits for account are locked\");\n            }\n\n            warmupInfo[_to] = Claim({\n                deposit: info.deposit + _amount,\n                gons: info.gons + sREQ.gonsForBalance(_amount),\n                expiry: epoch.number + warmupPeriod,\n                lock: info.lock\n            });\n\n            gonsInWarmup = gonsInWarmup + sREQ.gonsForBalance(_amount);\n\n            return _amount;\n        }\n    }\n\n    /**\n     * @notice retrieve stake from warmup\n     * @param _to address\n     * @param _rebasing bool\n     * @return uint\n     */\n    function claim(address _to, bool _rebasing) public returns (uint256) {\n        Claim memory info = warmupInfo[_to];\n\n        if (!info.lock) {\n            require(_to == msg.sender, \"External claims for account are locked\");\n        }\n\n        if (epoch.number >= info.expiry && info.expiry != 0) {\n            delete warmupInfo[_to];\n\n            gonsInWarmup -= info.gons;\n\n            return _send(_to, sREQ.balanceForGons(info.gons), _rebasing);\n        }\n        return 0;\n    }\n\n    /**\n     * @notice forfeit stake and retrieve REQ\n     * @return uint\n     */\n    function forfeit() external returns (uint256) {\n        Claim memory info = warmupInfo[msg.sender];\n        delete warmupInfo[msg.sender];\n\n        gonsInWarmup -= info.gons;\n\n        REQ.safeTransfer(msg.sender, info.deposit);\n\n        return info.deposit;\n    }\n\n    /**\n     * @notice prevent new deposits or claims from ext. address (protection from malicious activity)\n     */\n    function toggleLock() external {\n        warmupInfo[msg.sender].lock = !warmupInfo[msg.sender].lock;\n    }\n\n    /**\n     * @notice redeem sREQ for REQs\n     * @param _to address\n     * @param _amount uint\n     * @param _trigger bool\n     * @param _rebasing bool\n     * @return amount_ uint\n     */\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256 amount_) {\n        amount_ = _amount;\n        uint256 bounty;\n        if (_trigger) {\n            bounty = rebase();\n        }\n        if (_rebasing) {\n            sREQ.safeTransferFrom(msg.sender, address(this), _amount);\n            amount_ += bounty;\n        } else {\n            gREQ.burn(msg.sender, _amount); // amount was given in gREQ terms\n            amount_ = gREQ.balanceFrom(amount_) + bounty; // convert amount to REQ terms & add bounty\n        }\n\n        require(amount_ <= REQ.balanceOf(address(this)), \"Insufficient REQ balance in contract\");\n        REQ.safeTransfer(_to, amount_);\n    }\n\n    /**\n     * @notice convert _amount sREQ into gBalance_ gREQ\n     * @param _to address\n     * @param _amount uint\n     * @return gBalance_ uint\n     */\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_) {\n        sREQ.safeTransferFrom(msg.sender, address(this), _amount);\n        gBalance_ = gREQ.balanceTo(_amount);\n        gREQ.mint(_to, gBalance_);\n    }\n\n    /**\n     * @notice convert _amount gREQ into sBalance_ sREQ\n     * @param _to address\n     * @param _amount uint\n     * @return sBalance_ uint\n     */\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_) {\n        gREQ.burn(msg.sender, _amount);\n        sBalance_ = gREQ.balanceFrom(_amount);\n        sREQ.safeTransfer(_to, sBalance_);\n    }\n\n    /**\n     * @notice trigger rebase if epoch over\n     * @return uint256\n     */\n    function rebase() public returns (uint256) {\n        uint256 bounty;\n        if (epoch.end <= block.timestamp) {\n            sREQ.rebase(epoch.distribute, epoch.number);\n\n            epoch.end += epoch.length;\n            epoch.number++;\n\n            if (address(distributor) != address(0)) {\n                distributor.distribute();\n                bounty = distributor.retrieveBounty(); // Will mint req for this contract if there exists a bounty\n            }\n            uint256 balance = REQ.balanceOf(address(this));\n            uint256 staked = sREQ.circulatingSupply();\n            if (balance <= staked + bounty) {\n                epoch.distribute = 0;\n            } else {\n                epoch.distribute = balance - staked - bounty;\n            }\n        }\n        return bounty;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /**\n     * @notice send staker their amount as sREQ or gREQ\n     * @param _to address\n     * @param _amount uint\n     * @param _rebasing bool\n     */\n    function _send(\n        address _to,\n        uint256 _amount,\n        bool _rebasing\n    ) internal returns (uint256) {\n        if (_rebasing) {\n            sREQ.safeTransfer(_to, _amount); // send as sREQ (equal unit as REQ)\n            return _amount;\n        } else {\n            gREQ.mint(_to, gREQ.balanceTo(_amount)); // send as gREQ (convert units from REQ)\n            return gREQ.balanceTo(_amount);\n        }\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice returns the sREQ index, which tracks rebase growth\n     * @return uint\n     */\n    function index() public view returns (uint256) {\n        return sREQ.index();\n    }\n\n    /**\n     * @notice total supply in warmup\n     */\n    function supplyInWarmup() public view returns (uint256) {\n        return sREQ.balanceForGons(gonsInWarmup);\n    }\n\n    /**\n     * @notice seconds until the next epoch begins\n     */\n    function secondsToNextEpoch() external view returns (uint256) {\n        return epoch.end - block.timestamp;\n    }\n\n    /* ========== MANAGERIAL FUNCTIONS ========== */\n\n    /**\n     * @notice sets the contract address for LP staking\n     * @param _distributor address\n     */\n    function setDistributor(address _distributor) external onlyGovernor {\n        distributor = IDistributor(_distributor);\n        emit DistributorSet(_distributor);\n    }\n\n    /**\n     * @notice set warmup period for new stakers\n     * @param _warmupPeriod uint\n     */\n    function setWarmupLength(uint256 _warmupPeriod) external onlyGovernor {\n        warmupPeriod = _warmupPeriod;\n        emit WarmupSet(_warmupPeriod);\n    }\n}\n"
    },
    "contracts/interfaces/IgREQ.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IgREQ is IERC20 {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function index() external view returns (uint256);\n\n    function balanceFrom(uint256 _amount) external view returns (uint256);\n\n    function balanceTo(uint256 _amount) external view returns (uint256);\n\n    function migrate(address _staking, address _sREQ) external;\n}\n"
    },
    "contracts/StakingWarmup.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./interfaces/ERC20/IERC20.sol\";\n\ncontract StakingWarmup {\n\n    address public immutable staking;\n    address public immutable sREQT;\n\n    constructor ( address _staking, address _sREQT ) {\n        require( _staking != address(0) );\n        staking = _staking;\n        require( _sREQT != address(0) );\n        sREQT = _sREQT;\n    }\n\n    function retrieve( address _staker, uint _amount ) external {\n        require( msg.sender == staking );\n        IERC20( sREQT ).transfer( _staker, _amount );\n    }\n}"
    },
    "contracts/RequiemUV2BondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IUniswapV2TypePair.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SqrtMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemUV2BondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SqrtMath for uint256;\n\n  address public immutable REQT;\n\n  constructor(address _REQT) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n  }\n\n  function getKValue(address _pair) public view returns (uint256 k_) {\n    uint256 token0 = IERC20(IUniswapV2TypePair(_pair).token0()).decimals();\n    uint256 token1 = IERC20(IUniswapV2TypePair(_pair).token1()).decimals();\n    uint256 decimals = token0 + token1 - IERC20(_pair).decimals();\n\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2TypePair(_pair)\n      .getReserves();\n    k_ = (reserve0 * reserve1) / (10**decimals);\n  }\n\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    _value = getKValue(_pair).sqrrt() * 2;\n  }\n\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IUniswapV2TypePair(_pair).totalSupply();\n\n    _value = totalValue\n       * FixedPoint.fraction(amount_, totalSupply).decode112with18()\n      /1e18;\n  }\n\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2TypePair(_pair)\n      .getReserves();\n\n    uint256 reserve;\n    if (IUniswapV2TypePair(_pair).token0() == REQT) {\n      reserve = reserve1;\n    } else {\n      reserve = reserve0;\n    }\n    return\n      reserve * (2 * (10**IERC20(REQT).decimals())) / getTotalValue(_pair);\n  }\n}\n"
    },
    "contracts/interfaces/IUniswapV2TypePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\ninterface IUniswapV2TypePair {\n  function totalSupply() external view returns (uint256);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n}\n"
    },
    "contracts/libraries/math/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./FullMath.sol\";\n\nlibrary FixedPoint {\n  struct uq112x112 {\n    uint224 _x;\n  }\n\n  struct uq144x112 {\n    uint256 _x;\n  }\n\n  uint8 private constant RESOLUTION = 112;\n  uint256 private constant Q112 = 0x10000000000000000000000000000;\n  uint256 private constant Q224 =\n    0x100000000000000000000000000000000000000000000000000000000;\n  uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n  function decode(uq112x112 memory self) internal pure returns (uint112) {\n    return uint112(self._x >> RESOLUTION);\n  }\n\n  function decode112with18(uq112x112 memory self)\n    internal\n    pure\n    returns (uint256)\n  {\n    return uint256(self._x) / 5192296858534827;\n  }\n\n  function fraction(uint256 numerator, uint256 denominator)\n    internal\n    pure\n    returns (uq112x112 memory)\n  {\n    require(denominator > 0, \"FixedPoint::fraction: division by zero\");\n    if (numerator == 0) return FixedPoint.uq112x112(0);\n\n    if (numerator <= type(uint144).max) {\n      uint256 result = (numerator << RESOLUTION) / denominator;\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    } else {\n      uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n      require(result <= type(uint224).max, \"FixedPoint::fraction: overflow\");\n      return uq112x112(uint224(result));\n    }\n  }\n}\n"
    },
    "contracts/libraries/math/SqrtMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary SqrtMath {\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = a / 2 + 1;\n      while (b < c) {\n        c = b;\n        b = ((a / b) + b) / 2;\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
    },
    "contracts/libraries/math/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.11;\n\n// solhint-disable no-inline-assembly, reason-string, max-line-length\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            // EDIT for 0.8 compatibility:\n            // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\n            uint256 twos = denominator & (~denominator + 1);\n\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}"
    },
    "contracts/RequiemQBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemWeightedPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SqrtMath.sol\";\nimport \"./libraries/math/FullMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemQBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n\n  // 20 decimal sqrt 2\n  uint256 private immutable SQRT2x100 = 141421356237309504880;\n  address public immutable REQ;\n\n  constructor(address _REQ) {\n    require(_REQ != address(0));\n    REQ = _REQ;\n  }\n\n  /**\n   * note for general pairs the price does not necessarily satisfy the conditon\n   * that the lp value consists 50% of the one and the other token since the mid\n   * price is the quotient of the reserves. That is not necessarily the case for\n   * general pairs, therefore, we have to calculate the price separately and apply it\n   * to the reserve amount for conversion\n   * - calculates the total liquidity value denominated in the provided token\n   * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\n   *   have a too large impact\n   * - the sencond token input argument is ignored when using pools with only 2 tokens\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   *  - the value is calculated as the geometric average of input and output\n   *  - is consistent with the uniswapV2-type case\n   */\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair)\n      .getReserves();\n    (uint32 weight0, uint32 weight1) = IRequiemWeightedPair(_pair)\n      .getTokenWeights();\n\n    (uint256 reservesOther, , uint32 weightOther, uint32 weightReqt) = REQ ==\n      IRequiemWeightedPair(_pair).token0()\n      ? (reserve1, reserve0, weight1, weight0)\n      : (reserve0, reserve1, weight0, weight1);\n\n    // In case of both weights being 50, it is equivalent to\n    // the UniswapV2 variant. If the weights are different, we define the valuation by\n    // scaling the reqt reserve up or down dependent on the weights and the use the product as\n    // adjusted constant product. We will use the conservative estimation of the price - we upscale\n    // such that the reflected equivalent pool is a uniswapV2 with the higher liquidity that pruduces\n    // the same price of the Requiem token as the weighted pool.\n    _value =\n      (SQRT2x100 * reservesOther) /\n      SqrtMath.sqrrt(weightOther * weightOther + weightReqt * weightReqt) /\n      1e18;\n  }\n\n  /**\n   * - calculates the value in reqt of the input LP amount provided\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   * @param amount_ the amount of LP to price in REQ\n   *  - is consistent with the uniswapV2-type case\n   */\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemWeightedPair(_pair).totalSupply();\n\n    _value = FullMath.mulDivRoundingUp(totalValue, amount_, totalSupply);\n  }\n\n  // markdown function for bond valuation\n  function markdown(address _pair) external view returns (uint256) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair)\n      .getReserves();\n    (uint32 weight0, uint32 weight1) = IRequiemWeightedPair(_pair)\n      .getTokenWeights();\n\n    (uint256 reservesOther, uint32 weightOther, uint32 weightReqt) = REQ ==\n      IRequiemWeightedPair(_pair).token0()\n      ? (reserve1, weight1, weight0)\n      : (reserve0, weight0, weight1);\n\n    // adjusted markdown scaling up the reserve as the trading mechnism allows\n    // higher or lower valuation for reqt reserve\n    return\n      ((reservesOther + (weightOther * reservesOther) / weightReqt) *\n        (10**IERC20(REQ).decimals())) / getTotalValue(_pair);\n  }\n}\n"
    },
    "contracts/interfaces/IRequiemWeightedPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./IRequiemPairERC20.sol\";\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemWeightedPair is IRequiemPairERC20 {\n  event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function getCollectedFees()\n    external\n    view\n    returns (uint112 _collectedFee0, uint112 _collectedFee1);\n\n  function getTokenWeights()\n    external\n    view\n    returns (uint32 tokenWeight0, uint32 tokenWeight1);\n\n  function getSwapFee() external view returns (uint32);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(\n    address,\n    address,\n    uint32,\n    uint32\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRequiemSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\ninterface IRequiemSwap {\n  function calculateSwapGivenIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  ) external view returns (uint256);\n\n  function calculateSwapGivenOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRequiemPairERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n// solhint-disable func-name-mixedcase\n\ninterface IRequiemPairERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/RequiemPairBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemWeightedPair.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\nimport \"./libraries/math/SqrtMath.sol\";\nimport \"./libraries/math/FullMath.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemPairBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n\n  // address that is used for the quote of the provided pool\n  address public immutable QUOTE;\n\n  constructor(address _QUOTE) {\n    require(_QUOTE != address(0));\n    QUOTE = _QUOTE;\n  }\n\n  /**\n   * note for general pairs the price does not necessarily satisfy the conditon\n   * that the lp value consists 50% of the one and the other token since the mid\n   * price is the quotient of the reserves. That is not necessarily the case for\n   * general pairs, therefore, we have to calculate the price separately and apply it\n   * to the reserve amount for conversion\n   * - calculates the total liquidity value denominated in the provided token\n   * - uses the 1bps ouytput reserves for that calculation to avoid slippage to\n   *   have a too large impact\n   * - the sencond token input argument is ignored when using pools with only 2 tokens\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   *  - the value is calculated as the geometric average of input and output\n   *  - is consistent with the uniswapV2-type case\n   */\n  function getTotalValue(address _pair) public view returns (uint256 _value) {\n    (uint256 reserve0, uint256 reserve1, ) = IRequiemWeightedPair(_pair)\n      .getReserves();\n    (uint32 weight0, uint32 weight1) = IRequiemWeightedPair(_pair)\n      .getTokenWeights();\n\n    (, uint256 reserveQuote, uint32 weightOther, uint32 weightQuote) = QUOTE ==\n      IRequiemWeightedPair(_pair).token0()\n      ? (reserve1, reserve0, weight1, weight0)\n      : (reserve0, reserve1, weight0, weight1);\n\n    // In case of both weights being 50, it is equivalent to\n    // the UniswapV2 variant. If the weights are different, we define the valuation by\n    // scaling the reserve up or down dependent on the weights and the use the product as\n    // adjusted constant product. We will use the conservative estimation of the price - we upscale\n    // such that the reflected equivalent pool is a uniswapV2 with the higher liquidity that pruduces\n    // the same price of the Requiem token as the weighted pool.\n    _value =\n      reserveQuote +\n      FullMath.mulDivRoundingUp(reserveQuote, weightOther, weightQuote);\n\n    _value *= 10**(18 - IERC20(QUOTE).decimals());\n  }\n\n  /**\n   * - calculates the value in QUOTE  that backs reqt 1:1 of the input LP amount provided\n   * @param _pair general pair that has the RequiemSwap interface implemented\n   * @param amount_ the amount of LP to price for the backing\n   *  - is consistent with the uniswapV2-type case\n   */\n  function valuation(address _pair, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_pair);\n    uint256 totalSupply = IRequiemWeightedPair(_pair).totalSupply();\n\n    _value = FullMath.mulDivRoundingUp(totalValue, amount_, totalSupply);\n  }\n\n  // markdown function for bond valuation\n  function markdown(address _pair) external view returns (uint256) {\n    return getTotalValue(_pair);\n  }\n}\n"
    },
    "contracts/RequiemStableBondingCalculator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./interfaces/IBondingCalculator.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./interfaces/IRequiemStableSwap.sol\";\nimport \"./interfaces/IRequiemSwap.sol\";\nimport \"./libraries/math/SafeMath.sol\";\nimport \"./libraries/math/FixedPoint.sol\";\n\n/**\n * Bonding calculator for weighted pairs\n */\ncontract RequiemStableBondingCalculator is IBondingCalculator {\n  using FixedPoint for *;\n  using SafeMath for uint256;\n  using SafeMath for uint112;\n\n  address public immutable REQ;\n  address public immutable QUOTE;\n\n  constructor(address _REQ, address _QUOTE) {\n    require(_REQ != address(0));\n    require(_QUOTE != address(0));\n    REQ = _REQ;\n    QUOTE = _QUOTE;\n  }\n\n  // calculates the liquidity value denominated in the provided token\n  // uses the 0.1% inputAmount for that calculation\n  function getTotalValue(address _stablePool) public view returns (uint256 _value) {\n    uint256[] memory reserves = IRequiemStableSwap(_stablePool).getTokenBalances();\n    uint8 quoteIndex = IRequiemStableSwap(_stablePool).getTokenIndex(QUOTE);\n    for (uint8 i = 0; i < reserves.length; i++) {\n      if (i != quoteIndex) {\n        _value +=\n          IRequiemStableSwap(_stablePool).calculateSwap(\n            i,\n            quoteIndex,\n            reserves[i] / 10000\n          ) *\n          10000;\n      }\n    }\n  }\n\n  function valuation(address _stablePool, uint256 amount_)\n    external\n    view\n    override\n    returns (uint256 _value)\n  {\n    uint256 totalValue = getTotalValue(_stablePool);\n    uint256 totalSupply = IRequiemStableSwap(_stablePool).getLpToken().totalSupply();\n\n    _value = totalValue\n      .mul(FixedPoint.fraction(amount_, totalSupply).decode112with18())\n      .div(1e18);\n  }\n\n  function markdown(address _stablePool) external view returns (uint256) {\n    return getTotalValue(_stablePool);\n  }\n}\n"
    },
    "contracts/interfaces/IRequiemStableSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./ERC20/IERC20.sol\";\n\n// solhint-disable var-name-mixedcase\n\ninterface IRequiemStableSwap {\n\n  // pool data view functions\n  function getLpToken() external view returns (IERC20 lpToken);\n\n  function getA() external view returns (uint256);\n\n  function getAPrecise() external view returns (uint256);\n\n  function getToken(uint8 index) external view returns (IERC20);\n\n  function getTokens() external view returns (IERC20[] memory);\n\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\n\n  function getTokenBalance(uint8 index) external view returns (uint256);\n\n  function getTokenBalances() external view returns (uint256[] memory);\n\n  function getNumberOfTokens() external view returns (uint256);\n\n  function getVirtualPrice() external view returns (uint256);\n\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n    external\n    view\n    returns (uint256);\n\n  function calculateSwap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function calculateRemoveLiquidity(address account, uint256 amount)\n    external\n    view\n    returns (uint256[] memory);\n\n  function calculateRemoveLiquidityOneToken(\n    address account,\n    uint256 tokenAmount,\n    uint8 tokenIndex\n  ) external view returns (uint256 availableTokenAmount);\n\n  function getAdminBalances()\n    external\n    view\n    returns (uint256[] memory adminBalances);\n\n  function getAdminBalance(uint8 index) external view returns (uint256);\n\n  function calculateCurrentWithdrawFee(address account)\n    external\n    view\n    returns (uint256);\n\n  // state modifying functions\n  function swap(\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy,\n    address to,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function addLiquidity(\n    uint256[] calldata amounts,\n    uint256 minToMint,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidity(\n    uint256 amount,\n    uint256[] calldata minAmounts,\n    uint256 deadline\n  ) external returns (uint256[] memory);\n\n  function removeLiquidityOneToken(\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function removeLiquidityImbalance(\n    uint256[] calldata amounts,\n    uint256 maxBurnAmount,\n    uint256 deadline\n  ) external returns (uint256);\n\n  function updateUserWithdrawFee(address recipient, uint256 transferAmount)\n    external;\n}\n"
    },
    "contracts/libraries/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockBondDepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../libraries/math/FullMath.sol\";\nimport \"../libraries/math/FixedPoint.sol\";\n\ninterface IOwnable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n\n  function pushManagement(address newOwner_) external;\n\n  function pullManagement() external;\n}\n\ncontract Ownable is IOwnable {\n  address internal _owner;\n  address internal _newOwner;\n\n  event OwnershipPushed(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event OwnershipPulled(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    _owner = msg.sender;\n    emit OwnershipPushed(address(0), _owner);\n  }\n\n  function policy() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyPolicy() {\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceManagement() public virtual override onlyPolicy {\n    emit OwnershipPushed(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function pushManagement(address newOwner_)\n    public\n    virtual\n    override\n    onlyPolicy\n  {\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipPushed(_owner, newOwner_);\n    _newOwner = newOwner_;\n  }\n\n  function pullManagement() public virtual override {\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n    emit OwnershipPulled(_owner, _newOwner);\n    _owner = _newOwner;\n  }\n}\n\nlibrary SafeMath {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n\n  function sqrrt(uint256 a) internal pure returns (uint256 c) {\n    if (a > 3) {\n      c = a;\n      uint256 b = add(div(a, 2), 1);\n      while (b < c) {\n        c = b;\n        b = div(add(div(a, b), b), 2);\n      }\n    } else if (a != 0) {\n      c = 1;\n    }\n  }\n}\n\nlibrary Address {\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\n      data\n    );\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, errorMessage);\n  }\n\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  function toBytes32(address a) internal pure returns (bytes32 b) {\n    assembly {\n      let m := mload(0x40)\n      a := and(a, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n      mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n      mstore(0x40, add(m, 52))\n      b := m\n    }\n  }\n\n  function addressToString(address _address)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes32 _bytes = toBytes32(_address);\n    bytes memory HEX = \"0123456789abcdef\";\n    bytes memory _addr = new bytes(42);\n\n    _addr[0] = \"0\";\n    _addr[1] = \"x\";\n\n    for (uint256 i = 0; i < 20; i++) {\n      _addr[2 + i * 2] = HEX[uint8(_bytes[i + 12] >> 4)];\n      _addr[3 + i * 2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n    }\n\n    return string(_addr);\n  }\n}\n\ninterface IERC20 {\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  // TODO comment actual hash value.\n  bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID =\n    keccak256(\"ERC20Token\");\n\n  mapping(address => uint256) internal _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 internal _totalSupply;\n\n  string internal _name;\n\n  string internal _symbol;\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = decimals_;\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function totalSupply() public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      msg.sender,\n      _allowances[sender][msg.sender].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      msg.sender,\n      spender,\n      _allowances[msg.sender][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account_, uint256 ammount_) internal virtual {\n    require(account_ != address(0), \"ERC20: mint to the zero address\");\n    _beforeTokenTransfer(address(this), account_, ammount_);\n    _totalSupply = _totalSupply.add(ammount_);\n    _balances[account_] = _balances[account_].add(ammount_);\n    emit Transfer(address(this), account_, ammount_);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _beforeTokenTransfer(\n    address from_,\n    address to_,\n    uint256 amount_\n  ) internal virtual {}\n}\n\ninterface IERC2612Permit {\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function nonces(address owner) external view returns (uint256);\n}\n\nlibrary Counters {\n  using SafeMath for uint256;\n\n  struct Counter {\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    counter._value += 1;\n  }\n\n  function decrement(Counter storage counter) internal {\n    counter._value = counter._value.sub(1);\n  }\n}\n\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\n  using Counters for Counters.Counter;\n\n  mapping(address => Counters.Counter) private _nonces;\n\n  // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  bytes32 public constant PERMIT_TYPEHASH =\n    0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n  bytes32 public DOMAIN_SEPARATOR;\n\n  constructor() {\n    uint256 chainID;\n    assembly {\n      chainID := chainid()\n    }\n\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(name())),\n        keccak256(bytes(\"1\")), // Version\n        chainID,\n        address(this)\n      )\n    );\n  }\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"Permit: expired deadline\");\n\n    bytes32 hashStruct = keccak256(\n      abi.encode(\n        PERMIT_TYPEHASH,\n        owner,\n        spender,\n        amount,\n        _nonces[owner].current(),\n        deadline\n      )\n    );\n\n    bytes32 _hash = keccak256(\n      abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct)\n    );\n\n    address signer = ecrecover(_hash, v, r, s);\n    require(\n      signer != address(0) && signer == owner,\n      \"ZeroSwapPermit: Invalid signature\"\n    );\n\n    _nonces[owner].increment();\n    _approve(owner, spender, amount);\n  }\n\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner].current();\n  }\n}\n\nlibrary SafeERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender).sub(\n      value,\n      \"SafeERC20: decreased allowance below zero\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    bytes memory returndata = address(token).functionCall(\n      data,\n      \"SafeERC20: low-level call failed\"\n    );\n    if (returndata.length > 0) {\n      // Return data is optional\n      // solhint-disable-next-line max-line-length\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n\ninterface ITreasury {\n  function deposit(\n    uint256 _amount,\n    address _token,\n    uint256 _profit\n  ) external returns (bool);\n\n  function valueOfToken(address _token, uint256 _amount)\n    external\n    view\n    returns (uint256 value_);\n}\n\ninterface IBondCalculator {\n  function valuation(address _LP, uint256 _amount)\n    external\n    view\n    returns (uint256);\n\n  function markdown(address _LP) external view returns (uint256);\n}\n\ninterface IStaking {\n  function stake(uint256 _amount, address _recipient) external returns (bool);\n}\n\ninterface IStakingHelper {\n  function stake(uint256 _amount, address _recipient) external;\n}\n\ncontract MockBondDepository is Ownable {\n  using FixedPoint for *;\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n\n  /* ======== EVENTS ======== */\n\n  event BondCreated(\n    uint256 deposit,\n    uint256 indexed payout,\n    uint256 indexed expires,\n    uint256 indexed priceInUSD\n  );\n  event BondRedeemed(\n    address indexed recipient,\n    uint256 payout,\n    uint256 remaining\n  );\n  event BondPriceChanged(\n    uint256 indexed priceInUSD,\n    uint256 indexed internalPrice,\n    uint256 indexed debtRatio\n  );\n  event ControlVariableAdjustment(\n    uint256 initialBCV,\n    uint256 newBCV,\n    uint256 adjustment,\n    bool addition\n  );\n\n  /* ======== STATE VARIABLES ======== */\n\n  address public immutable REQT; // token given as payment for bond\n  address public immutable principle; // token used to create bond\n  address public immutable treasury; // mints REQT when receives principle\n  address public immutable DAO; // receives profit share from bond\n\n  bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n  address public immutable bondCalculator; // calculates value of LP tokens\n\n  address public staking; // to auto-stake payout\n  address public stakingHelper; // to stake and claim if no staking warmup\n  bool public useHelper;\n\n  Terms public terms; // stores terms for new bonds\n  Adjust public adjustment; // stores adjustment to BCV data\n\n  mapping(address => Bond) public bondInfo; // stores bond information for depositors\n\n  uint256 public totalDebt; // total value of outstanding bonds; used for pricing\n  uint256 public lastDecay; // reference block for debt decay\n\n  /* ======== STRUCTS ======== */\n\n  // Info for creating new bonds\n  struct Terms {\n    uint256 controlVariable; // scaling variable for price\n    uint256 vestingTerm; // in blocks\n    uint256 minimumPrice; // vs principle value\n    uint256 maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n    uint256 fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n    uint256 maxDebt; // 9 decimal debt ratio, max % total supply created as debt\n  }\n\n  // Info for bond holder\n  struct Bond {\n    uint256 payout; // REQT remaining to be paid\n    uint256 vesting; // Blocks left to vest\n    uint256 lastBlock; // Last interaction\n    uint256 pricePaid; // In DAI, for front end viewing\n  }\n\n  // Info for incremental adjustments to control variable\n  struct Adjust {\n    bool add; // addition or subtraction\n    uint256 rate; // increment\n    uint256 target; // BCV when adjustment finished\n    uint256 buffer; // minimum length (in blocks) between adjustments\n    uint256 lastBlock; // block when last adjustment made\n  }\n\n  /* ======== INITIALIZATION ======== */\n\n  constructor(\n    address _REQT,\n    address _principle,\n    address _treasury,\n    address _DAO,\n    address _bondCalculator\n  ) {\n    require(_REQT != address(0));\n    REQT = _REQT;\n    require(_principle != address(0));\n    principle = _principle;\n    require(_treasury != address(0));\n    treasury = _treasury;\n    require(_DAO != address(0));\n    DAO = _DAO;\n    // bondCalculator should be address(0) if not LP bond\n    bondCalculator = _bondCalculator;\n    isLiquidityBond = (_bondCalculator != address(0));\n  }\n\n  /**\n   *  @notice initializes bond parameters\n   *  @param _controlVariable uint\n   *  @param _vestingTerm uint\n   *  @param _minimumPrice uint\n   *  @param _maxPayout uint\n   *  @param _fee uint\n   *  @param _maxDebt uint\n   *  @param _initialDebt uint\n   */\n  function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _fee,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    require(terms.controlVariable == 0, \"Bonds must be initialized from 0\");\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      fee: _fee,\n      maxDebt: _maxDebt\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }\n\n  /* ======== POLICY FUNCTIONS ======== */\n\n  enum PARAMETER {\n    VESTING,\n    PAYOUT,\n    FEE,\n    DEBT\n  }\n\n  /**\n   *  @notice set parameters for new bonds\n   *  @param _parameter PARAMETER\n   *  @param _input uint\n   */\n  function setBondTerms(PARAMETER _parameter, uint256 _input)\n    external\n    onlyPolicy\n  {\n    if (_parameter == PARAMETER.VESTING) {\n      // 0\n      require(_input >= 10000, \"Vesting must be longer than 36 hours\");\n      terms.vestingTerm = _input;\n    } else if (_parameter == PARAMETER.PAYOUT) {\n      // 1\n      require(_input <= 1000, \"Payout cannot be above 1 percent\");\n      terms.maxPayout = _input;\n    } else if (_parameter == PARAMETER.FEE) {\n      // 2\n      require(_input <= 10000, \"DAO fee cannot exceed payout\");\n      terms.fee = _input;\n    } else if (_parameter == PARAMETER.DEBT) {\n      // 3\n      terms.maxDebt = _input;\n    }\n  }\n\n  /**\n   *  @notice set control variable adjustment\n   *  @param _addition bool\n   *  @param _increment uint\n   *  @param _target uint\n   *  @param _buffer uint\n   */\n  function setAdjustment(\n    bool _addition,\n    uint256 _increment,\n    uint256 _target,\n    uint256 _buffer\n  ) external onlyPolicy {\n    require(\n      _increment <= terms.controlVariable.mul(25).div(1000),\n      \"Increment too large\"\n    );\n\n    adjustment = Adjust({\n      add: _addition,\n      rate: _increment,\n      target: _target,\n      buffer: _buffer,\n      lastBlock: block.number\n    });\n  }\n\n  /**\n   *  @notice set contract for auto stake\n   *  @param _staking address\n   *  @param _helper bool\n   */\n  function setStaking(address _staking, bool _helper) external onlyPolicy {\n    require(_staking != address(0));\n    if (_helper) {\n      useHelper = true;\n      stakingHelper = _staking;\n    } else {\n      useHelper = false;\n      staking = _staking;\n    }\n  }\n\n  /* ======== USER FUNCTIONS ======== */\n\n  /**\n   *  @notice deposit bond\n   *  @param _amount uint\n   *  @param _maxPrice uint\n   *  @param _depositor address\n   *  @return uint\n   */\n  function deposit(\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _depositor\n  ) external returns (uint256) {\n    require(_depositor != address(0), \"Invalid address\");\n\n    decayDebt();\n    require(totalDebt <= terms.maxDebt, \"Max capacity reached\");\n\n    uint256 priceInUSD = bondPriceInUSD(); // Stored in bond info\n    uint256 nativePrice = _bondPrice();\n\n    require(_maxPrice >= nativePrice, \"Slippage limit: more than max price\"); // slippage protection\n\n    uint256 value = ITreasury(treasury).valueOfToken(principle, _amount);\n    uint256 payout = payoutFor(value); // payout to bonder is computed\n\n    require(payout >= 10000000, \"Bond too small\"); // must be > 0.01 REQT ( underflow protection )\n    require(payout <= maxPayout(), \"Bond too large\"); // size protection because there is no slippage\n\n    // profits are calculated\n    uint256 fee = payout.mul(terms.fee).div(10000);\n    uint256 profit = value.sub(payout).sub(fee);\n\n    /**\n            principle is transferred in\n            approved and\n            deposited into the treasury, returning (_amount - profit) REQT\n         */\n    IERC20(principle).safeTransferFrom(msg.sender, address(this), _amount);\n    IERC20(principle).approve(address(treasury), _amount);\n    ITreasury(treasury).deposit(_amount, principle, profit);\n\n    if (fee != 0) {\n      // fee is transferred to dao\n      IERC20(REQT).safeTransfer(DAO, fee);\n    }\n\n    // total debt is increased\n    totalDebt = totalDebt.add(value);\n\n    // depositor info is stored\n    bondInfo[_depositor] = Bond({\n      payout: bondInfo[_depositor].payout.add(payout),\n      vesting: terms.vestingTerm,\n      lastBlock: block.number,\n      pricePaid: priceInUSD\n    });\n\n    // indexed events are emitted\n    emit BondCreated(\n      _amount,\n      payout,\n      block.number.add(terms.vestingTerm),\n      priceInUSD\n    );\n    emit BondPriceChanged(bondPriceInUSD(), _bondPrice(), debtRatio());\n\n    adjust(); // control variable is adjusted\n    return payout;\n  }\n\n  /**\n   *  @notice redeem bond for user\n   *  @param _recipient address\n   *  @param _stake bool\n   *  @return uint\n   */\n  function redeem(address _recipient, bool _stake) external returns (uint256) {\n    Bond memory info = bondInfo[_recipient];\n    uint256 percentVested = percentVestedFor(_recipient); // (blocks since last interaction / vesting term remaining)\n\n    if (percentVested >= 10000) {\n      // if fully vested\n      delete bondInfo[_recipient]; // delete user info\n      emit BondRedeemed(_recipient, info.payout, 0); // emit bond data\n      return stakeOrSend(_recipient, _stake, info.payout); // pay user everything due\n    } else {\n      // if unfinished\n      // calculate payout vested\n      uint256 payout = info.payout.mul(percentVested).div(10000);\n\n      // store updated deposit info\n      bondInfo[_recipient] = Bond({\n        payout: info.payout.sub(payout),\n        vesting: info.vesting.sub(block.number.sub(info.lastBlock)),\n        lastBlock: block.number,\n        pricePaid: info.pricePaid\n      });\n\n      emit BondRedeemed(_recipient, payout, bondInfo[_recipient].payout);\n      return stakeOrSend(_recipient, _stake, payout);\n    }\n  }\n\n  /* ======== INTERNAL HELPER FUNCTIONS ======== */\n\n  /**\n   *  @notice allow user to stake payout automatically\n   *  @param _stake bool\n   *  @param _amount uint\n   *  @return uint\n   */\n  function stakeOrSend(\n    address _recipient,\n    bool _stake,\n    uint256 _amount\n  ) internal returns (uint256) {\n    if (!_stake) {\n      // if user does not want to stake\n      IERC20(REQT).transfer(_recipient, _amount); // send payout\n    } else {\n      // if user wants to stake\n      if (useHelper) {\n        // use if staking warmup is 0\n        IERC20(REQT).approve(stakingHelper, _amount);\n        IStakingHelper(stakingHelper).stake(_amount, _recipient);\n      } else {\n        IERC20(REQT).approve(staking, _amount);\n        IStaking(staking).stake(_amount, _recipient);\n      }\n    }\n    return _amount;\n  }\n\n  /**\n   *  @notice makes incremental adjustment to control variable\n   */\n  function adjust() internal {\n    uint256 blockCanAdjust = adjustment.lastBlock.add(adjustment.buffer);\n    if (adjustment.rate != 0 && block.number >= blockCanAdjust) {\n      uint256 initial = terms.controlVariable;\n      if (adjustment.add) {\n        terms.controlVariable = terms.controlVariable.add(adjustment.rate);\n        if (terms.controlVariable >= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      } else {\n        terms.controlVariable = terms.controlVariable.sub(adjustment.rate);\n        if (terms.controlVariable <= adjustment.target) {\n          adjustment.rate = 0;\n        }\n      }\n      adjustment.lastBlock = block.number;\n      emit ControlVariableAdjustment(\n        initial,\n        terms.controlVariable,\n        adjustment.rate,\n        adjustment.add\n      );\n    }\n  }\n\n  /**\n   *  @notice reduce total debt\n   */\n  function decayDebt() internal {\n    totalDebt = totalDebt.sub(debtDecay());\n    lastDecay = block.number;\n  }\n\n  /* ======== VIEW FUNCTIONS ======== */\n\n  /**\n   *  @notice determine maximum bond size\n   *  @return uint\n   */\n  function maxPayout() public view returns (uint256) {\n    return IERC20(REQT).totalSupply().mul(terms.maxPayout).div(100000);\n  }\n\n  /**\n   *  @notice calculate interest due for new bond\n   *  @param _value uint\n   *  @return uint\n   */\n  function payoutFor(uint256 _value) public view returns (uint256) {\n    return FixedPoint.fraction(_value, bondPrice()).decode112with18().div(1e16);\n  }\n\n  /**\n   *  @notice calculate current bond premium\n   *  @return price_ uint\n   */\n  function bondPrice() public view returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    }\n  }\n\n  /**\n   *  @notice calculate current bond price and remove floor if above\n   *  @return price_ uint\n   */\n  function _bondPrice() internal returns (uint256 price_) {\n    price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(1e7);\n    if (price_ < terms.minimumPrice) {\n      price_ = terms.minimumPrice;\n    } else if (terms.minimumPrice != 0) {\n      terms.minimumPrice = 0;\n    }\n  }\n\n  /**\n   *  @notice converts bond price to DAI value\n   *  @return price_ uint\n   */\n  function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n      price_ = bondPrice()\n        .mul(IBondCalculator(bondCalculator).markdown(principle))\n        .div(100);\n    } else {\n      price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\n    }\n  }\n\n  /**\n   *  @notice calculate current ratio of debt to REQT supply\n   *  @return debtRatio_ uint\n   */\n  function debtRatio() public view returns (uint256 debtRatio_) {\n    uint256 supply = IERC20(REQT).totalSupply();\n    debtRatio_ = FixedPoint\n      .fraction(currentDebt().mul(1e9), supply)\n      .decode112with18()\n      .div(1e18);\n  }\n\n  /**\n   *  @notice debt ratio in same terms for reserve or liquidity bonds\n   *  @return uint\n   */\n  function standardizedDebtRatio() external view returns (uint256) {\n    if (isLiquidityBond) {\n      return\n        debtRatio()\n          .mul(IBondCalculator(bondCalculator).markdown(principle))\n          .div(1e9);\n    } else {\n      return debtRatio();\n    }\n  }\n\n  /**\n   *  @notice calculate debt factoring in decay\n   *  @return uint\n   */\n  function currentDebt() public view returns (uint256) {\n    return totalDebt.sub(debtDecay());\n  }\n\n  /**\n   *  @notice amount to decay total debt by\n   *  @return decay_ uint\n   */\n  function debtDecay() public view returns (uint256 decay_) {\n    uint256 blocksSinceLast = block.number.sub(lastDecay);\n    decay_ = totalDebt.mul(blocksSinceLast).div(terms.vestingTerm);\n    if (decay_ > totalDebt) {\n      decay_ = totalDebt;\n    }\n  }\n\n  /**\n   *  @notice calculate how far into vesting a depositor is\n   *  @param _depositor address\n   *  @return percentVested_ uint\n   */\n  function percentVestedFor(address _depositor)\n    public\n    view\n    returns (uint256 percentVested_)\n  {\n    Bond memory bond = bondInfo[_depositor];\n    uint256 blocksSinceLast = block.number.sub(bond.lastBlock);\n    uint256 vesting = bond.vesting;\n\n    if (vesting > 0) {\n      percentVested_ = blocksSinceLast.mul(10000).div(vesting);\n    } else {\n      percentVested_ = 0;\n    }\n  }\n\n  /**\n   *  @notice calculate amount of REQT available for claim by depositor\n   *  @param _depositor address\n   *  @return pendingPayout_ uint\n   */\n  function pendingPayoutFor(address _depositor)\n    external\n    view\n    returns (uint256 pendingPayout_)\n  {\n    uint256 percentVested = percentVestedFor(_depositor);\n    uint256 payout = bondInfo[_depositor].payout;\n\n    if (percentVested >= 10000) {\n      pendingPayout_ = payout;\n    } else {\n      pendingPayout_ = payout.mul(percentVested).div(10000);\n    }\n  }\n\n  /* ======= AUXILLIARY ======= */\n\n  /**\n   *  @notice allow anyone to send lost tokens (excluding principle or REQT) to the DAO\n   *  @return bool\n   */\n  function recoverLostToken(address _token) external returns (bool) {\n    require(_token != REQT);\n    require(_token != principle);\n    IERC20(_token).safeTransfer(DAO, IERC20(_token).balanceOf(address(this)));\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/SafeERC20 copy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.11;\n\nimport {IERC20} from \"../interfaces/ERC20/IERC20.sol\";\n\n// solhint-disable  max-line-length\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC201 {\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n    );\n\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TRANSFER_FROM_FAILED\"\n    );\n  }\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 amount\n  ) internal {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n    );\n\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"TRANSFER_FAILED\"\n    );\n  }\n\n  function safeApprove(\n    IERC20 token,\n    address to,\n    uint256 amount\n  ) internal {\n    (bool success, bytes memory data) = address(token).call(\n      abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n    );\n\n    require(\n      success && (data.length == 0 || abi.decode(data, (bool))),\n      \"APPROVE_FAILED\"\n    );\n  }\n\n  function safeTransferETH(address to, uint256 amount) internal {\n    (bool success, ) = to.call{value: amount}(new bytes(0));\n\n    require(success, \"ETH_TRANSFER_FAILED\");\n  }\n}\n"
    },
    "contracts/interfaces/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IRewarder {\n  function onReward(\n    uint256 pid,\n    address user,\n    address recipient,\n    uint256 rewardAmount,\n    uint256 newLpAmount\n  ) external;\n\n  function pendingTokens(\n    uint256 pid,\n    address user,\n    uint256 rewardAmount\n  ) external view returns (IERC20[] memory, uint256[] memory);\n}\n"
    },
    "contracts/rewarders/ComplexRewarderTime.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.11;\n\nimport \"../interfaces/IRewarder.sol\";\nimport \"../interfaces/IMiniChefV2.sol\";\nimport \"../libraries/Ownable.sol\";\nimport \"../libraries/SafeERC20.sol\";\n\ncontract ComplexRewarderTime is IRewarder, Ownable {\n  using SafeERC20 for IERC20;\n\n  IERC20 private rewardToken;\n\n  /// @notice Info of each MCV2 user.\n  /// `amount` LP token amount the user has provided.\n  /// `rewardDebt` The amount of reward entitled to the user.\n  struct UserInfo {\n    uint256 amount;\n    uint256 rewardDebt;\n  }\n\n  /// @notice Info of each MCV2 pool.\n  /// `allocPoint` The amount of allocation points assigned to the pool.\n  /// Also known as the amount of SUSHI to distribute per block.\n  struct PoolInfo {\n    uint256 accRewardPerShare;\n    uint256 lastRewardTime;\n    uint256 allocPoint;\n  }\n\n  /// @notice Info of each pool.\n  mapping(uint256 => PoolInfo) public poolInfo;\n\n  uint256[] public poolIds;\n\n  /// @notice Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n  /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\n  uint256 totalAllocPoint;\n\n  uint256 public rewardPerSecond;\n  uint256 private constant ACC_TOKEN_PRECISION = 1e12;\n\n  address private REQUIEM_CHEF;\n\n  event LogOnReward(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount,\n    address indexed to\n  );\n  event LogPoolAddition(uint256 indexed pid, uint256 allocPoint);\n  event LogSetPool(uint256 indexed pid, uint256 allocPoint);\n  event LogUpdatePool(\n    uint256 indexed pid,\n    uint256 lastRewardTime,\n    uint256 lpSupply,\n    uint256 accRewardPerShare\n  );\n  event LogRewardPerSecond(uint256 rewardPerSecond);\n  event LogInit();\n\n  constructor(\n    IERC20 _rewardToken,\n    uint256 _rewardPerSecond,\n    address _REQUIEM_CHEF\n  ) {\n    rewardToken = _rewardToken;\n    rewardPerSecond = _rewardPerSecond;\n    REQUIEM_CHEF = _REQUIEM_CHEF;\n  }\n\n  function onReward(\n    uint256 pid,\n    address _user,\n    address to,\n    uint256,\n    uint256 lpToken\n  ) external override onlyMCV2 {\n    PoolInfo memory pool = updatePool(pid);\n    UserInfo storage user = userInfo[pid][_user];\n    uint256 pending;\n    if (user.amount > 0) {\n      pending =\n        (user.amount * pool.accRewardPerShare) /\n        ACC_TOKEN_PRECISION -\n        user.rewardDebt;\n      rewardToken.safeTransfer(to, pending);\n    }\n    user.amount = lpToken;\n    user.rewardDebt = (lpToken * pool.accRewardPerShare) / ACC_TOKEN_PRECISION;\n    emit LogOnReward(_user, pid, pending, to);\n  }\n\n  function pendingTokens(\n    uint256 pid,\n    address user,\n    uint256\n  )\n    external\n    view\n    override\n    returns (IERC20[] memory rewardTokens, uint256[] memory rewardAmounts)\n  {\n    IERC20[] memory _rewardTokens = new IERC20[](1);\n    _rewardTokens[0] = (rewardToken);\n    uint256[] memory _rewardAmounts = new uint256[](1);\n    _rewardAmounts[0] = pendingToken(pid, user);\n    return (_rewardTokens, _rewardAmounts);\n  }\n\n  /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\n  /// @param _rewardPerSecond The amount of Sushi to be distributed per second.\n  function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\n    rewardPerSecond = _rewardPerSecond;\n    emit LogRewardPerSecond(_rewardPerSecond);\n  }\n\n  modifier onlyMCV2() {\n    require(msg.sender == REQUIEM_CHEF, \"Only MCV2 can call this function.\");\n    _;\n  }\n\n  /// @notice Returns the number of MCV2 pools.\n  function poolLength() public view returns (uint256 pools) {\n    pools = poolIds.length;\n  }\n\n  /// @notice Add a new LP to the pool. Can only be called by the owner.\n  /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n  /// @param allocPoint AP of the new pool.\n  /// @param _pid Pid on MCV2\n  function add(uint256 allocPoint, uint256 _pid) public onlyOwner {\n    require(poolInfo[_pid].lastRewardTime == 0, \"Pool already exists\");\n    uint256 lastRewardTime = block.timestamp;\n    totalAllocPoint += allocPoint;\n\n    poolInfo[_pid] = PoolInfo({\n      allocPoint: allocPoint,\n      lastRewardTime: lastRewardTime,\n      accRewardPerShare: 0\n    });\n    poolIds.push(_pid);\n    emit LogPoolAddition(_pid, allocPoint);\n  }\n\n  /// @notice Update the given pool's reward allocation point and `IRewarder` contract. Can only be called by the owner.\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _allocPoint New AP of the pool.\n  function set(uint256 _pid, uint256 _allocPoint) public onlyOwner {\n    totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\n    poolInfo[_pid].allocPoint = _allocPoint;\n    emit LogSetPool(_pid, _allocPoint);\n  }\n\n  /// @notice View function to see pending Token\n  /// @param _pid The index of the pool. See `poolInfo`.\n  /// @param _user Address of user.\n  /// @return pending reward for a given user.\n  function pendingToken(uint256 _pid, address _user)\n    public\n    view\n    returns (uint256 pending)\n  {\n    PoolInfo memory pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_user];\n    uint256 accRewardPerShare = pool.accRewardPerShare;\n    uint256 lpSupply = IMiniChefV2(REQUIEM_CHEF).lpToken(_pid).balanceOf(\n      REQUIEM_CHEF\n    );\n    if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\n      uint256 time = block.timestamp - pool.lastRewardTime;\n      uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n        totalAllocPoint;\n      accRewardPerShare += (rewardAmount * ACC_TOKEN_PRECISION) / lpSupply;\n    }\n    pending =\n      (user.amount * accRewardPerShare) /\n      ACC_TOKEN_PRECISION -\n      user.rewardDebt;\n  }\n\n  /// @notice Update reward variables for all pools. Be careful of gas spending!\n  /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n  function massUpdatePools(uint256[] calldata pids) external {\n    uint256 len = pids.length;\n    for (uint256 i = 0; i < len; ++i) {\n      updatePool(pids[i]);\n    }\n  }\n\n  /// @notice Update reward variables of the given pool.\n  /// @param pid The index of the pool. See `poolInfo`.\n  /// @return pool Returns the pool that was updated.\n  function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n    pool = poolInfo[pid];\n    if (block.timestamp > pool.lastRewardTime) {\n      uint256 lpSupply = IMiniChefV2(REQUIEM_CHEF).lpToken(pid).balanceOf(\n        REQUIEM_CHEF\n      );\n\n      if (lpSupply > 0) {\n        uint256 time = block.timestamp - pool.lastRewardTime;\n        uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) /\n          totalAllocPoint;\n        pool.accRewardPerShare =\n          pool.accRewardPerShare +\n          (rewardAmount * ACC_TOKEN_PRECISION) /\n          lpSupply;\n      }\n      pool.lastRewardTime = block.timestamp;\n      poolInfo[pid] = pool;\n      emit LogUpdatePool(\n        pid,\n        pool.lastRewardTime,\n        lpSupply,\n        pool.accRewardPerShare\n      );\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IMiniChefV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\nimport \"./ERC20/IERC20.sol\";\n\ninterface IMiniChefV2 {\n  function lpToken(uint256 _pid) external view returns (IERC20);\n}\n"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../interfaces/IOwnable.sol\";\n\ncontract Ownable is IOwnable {\n    \n  address internal _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor () {\n    _owner = msg.sender;\n    emit OwnershipTransferred( address(0), _owner );\n  }\n\n  function owner() public view override returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n    _;\n  }\n\n  function renounceOwnership() public virtual override onlyOwner() {\n    emit OwnershipTransferred( _owner, address(0) );\n    _owner = address(0);\n  }\n\n  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n    require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred( _owner, newOwner_ );\n    _owner = newOwner_;\n  }\n}"
    },
    "contracts/RedRequiem.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"./libraries/ERC20Burnable.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./libraries/Ownable.sol\";\nimport \"./interfaces/IGovernanceToken.sol\";\n\ncontract RedRequiem is ERC20Burnable, IGovernanceToken, Ownable {\n    using SafeERC20 for IERC20;\n\n    // flags\n    uint256 private _unlocked;\n\n    uint256 public constant MINDAYS = 7;\n    uint256 public constant MAXDAYS = 3 * 365;\n\n    uint256 public constant MAXTIME = MAXDAYS * 1 days; // 3 years\n    uint256 public constant MAX_WITHDRAWAL_PENALTY = 50000; // 50%\n    uint256 public constant PRECISION = 100000; // 5 decimals\n\n    address public lockedToken;\n    address public penaltyCollector;\n    uint256 public minLockedAmount;\n    uint256 public earlyWithdrawPenaltyRate;\n\n    struct LockedBalance {\n        uint256 amount;\n        uint256 end;\n    }\n\n    mapping(address => LockedBalance) public locked;\n    mapping(address => uint256) public mintedForLock;\n\n    /* ========== MODIFIERS ========== */\n\n    modifier lock() {\n        require(_unlocked == 1, \"LOCKED\");\n        _unlocked = 0;\n        _;\n        _unlocked = 1;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _lockedToken,\n        uint256 _minLockedAmount) ERC20(_name, _symbol, 18)\n    {\n        lockedToken = _lockedToken;\n        minLockedAmount = _minLockedAmount;\n        earlyWithdrawPenaltyRate = 30000; // 30%\n        _unlocked = 1;\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    function locked__of(address _addr) external view override returns (uint256) {\n        return locked[_addr].amount;\n    }\n\n    function locked__end(address _addr) external view override returns (uint256) {\n        return locked[_addr].end;\n    }\n\n    function voting_power_unlock_time(uint256 _value, uint256 _unlock_time) public view override returns (uint256) {\n        uint256 _now = block.timestamp;\n        if (_unlock_time <= _now) return 0;\n        uint256 _lockedSeconds = _unlock_time - _now;\n        if (_lockedSeconds >= MAXTIME) {\n            return _value;\n        }\n        return _value * _lockedSeconds / MAXTIME;\n    }\n\n    function voting_power_locked_days(uint256 _value, uint256 _days) public pure override returns (uint256) {\n        if (_days >= MAXDAYS) {\n            return _value;\n        }\n        return _value * _days / MAXDAYS;\n    }\n\n    function deposit_for(address _addr, uint256 _value) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        _deposit_for(_addr, _value, 0);\n    }\n\n    function create_lock(uint256 _value, uint256 _days) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        require(locked[_msgSender()].amount == 0, \"Withdraw old tokens first\");\n        require(_days >= MINDAYS, \"Voting lock can be 7 days min\");\n        require(_days <= MAXDAYS, \"Voting lock can be 4 years max\");\n        _deposit_for(_msgSender(), _value, _days);\n    }\n\n    function increase_amount(uint256 _value) external override {\n        require(_value >= minLockedAmount, \"less than min amount\");\n        _deposit_for(_msgSender(), _value, 0);\n    }\n\n    function increase_unlock_time(uint256 _days) external override {\n        require(_days >= MINDAYS, \"Voting lock can be 7 days min\");\n        require(_days <= MAXDAYS, \"Voting lock can be 4 years max\");\n        _deposit_for(_msgSender(), 0, _days);\n    }\n\n    function withdraw() external override lock {\n        LockedBalance storage _locked = locked[_msgSender()];\n        uint256 _now = block.timestamp;\n        require(_locked.amount > 0, \"Nothing to withdraw\");\n        require(_now >= _locked.end, \"The lock didn't expire\");\n        uint256 _amount = _locked.amount;\n        _locked.end = 0;\n        _locked.amount = 0;\n        _burn(_msgSender(), mintedForLock[_msgSender()]);\n        mintedForLock[_msgSender()] = 0;\n        IERC20(lockedToken).safeTransfer(_msgSender(), _amount);\n\n        emit Withdraw(_msgSender(), _amount, _now);\n    }\n\n    // This will charge PENALTY if lock is not expired yet\n    function emergencyWithdraw() external lock {\n        LockedBalance storage _locked = locked[_msgSender()];\n        uint256 _now = block.timestamp;\n        require(_locked.amount > 0, \"Nothing to withdraw\");\n        uint256 _amount = _locked.amount;\n        if (_now < _locked.end) {\n            uint256 _fee = _amount * earlyWithdrawPenaltyRate / PRECISION;\n            _penalize(_fee);\n            _amount = _amount - _fee;\n        }\n        _locked.end = 0;\n        _locked.amount = 0;\n        _burn(_msgSender(), mintedForLock[_msgSender()]);\n        mintedForLock[_msgSender()] = 0;\n\n        IERC20(lockedToken).safeTransfer(_msgSender(), _amount);\n\n        emit Withdraw(_msgSender(), _amount, _now);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _deposit_for(\n        address _addr,\n        uint256 _value,\n        uint256 _days\n    ) internal lock {\n        LockedBalance storage _locked = locked[_addr];\n        uint256 _now = block.timestamp;\n        uint256 _amount = _locked.amount;\n        uint256 _end = _locked.end;\n        uint256 _vp;\n        if (_amount == 0) {\n            _vp = voting_power_locked_days(_value, _days);\n            _locked.amount = _value;\n            _locked.end = _now + _days * 1 days;\n        } else if (_days == 0) {\n            _vp = voting_power_unlock_time(_value, _end);\n            _locked.amount = _amount + _value;\n        } else {\n            require(_value == 0, \"Cannot increase amount and extend lock in the same time\");\n            _vp = voting_power_locked_days(_amount, _days);\n            _locked.end = _end + _days * 1 days;\n            require(_locked.end - _now <= MAXTIME, \"Cannot extend lock to more than 4 years\");\n        }\n        require(_vp > 0, \"No benefit to lock\");\n        if (_value > 0) {\n            IERC20(lockedToken).safeTransferFrom(_msgSender(), address(this), _value);\n        }\n        _mint(_addr, _vp);\n        mintedForLock[_addr] += _vp;\n\n        emit Deposit(_addr, _locked.amount, _locked.end, _now);\n    }\n\n    function _penalize(uint256 _amount) internal {\n        if (penaltyCollector != address(0)) {\n            // send to collector if `penaltyCollector` set\n            IERC20(lockedToken).safeTransfer(penaltyCollector, _amount);\n        } else {\n            ERC20Burnable(lockedToken).burn(_amount);\n        }\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function setMinLockedAmount(uint256 _minLockedAmount) external onlyOwner {\n        minLockedAmount = _minLockedAmount;\n        emit MinLockedAmountSet(_minLockedAmount);\n    }\n\n    function setEarlyWithdrawPenaltyRate(uint256 _earlyWithdrawPenaltyRate) external onlyOwner {\n        require(_earlyWithdrawPenaltyRate <= MAX_WITHDRAWAL_PENALTY, \"withdrawal penalty is too high\"); // <= 50%\n        earlyWithdrawPenaltyRate = _earlyWithdrawPenaltyRate;\n        emit EarlyWithdrawPenaltySet(_earlyWithdrawPenaltyRate);\n    }\n\n    function setPenaltyCollector(address _addr) external onlyOwner {\n        penaltyCollector = _addr;\n        emit PenaltyCollectorSet(_addr);\n    }\n\n    /* =============== EVENTS ==================== */\n    event Deposit(address indexed provider, uint256 value, uint256 locktime, uint256 timestamp);\n    event Withdraw(address indexed provider, uint256 value, uint256 timestamp);\n    event PenaltyCollectorSet(address indexed addr);\n    event EarlyWithdrawPenaltySet(uint256 indexed penalty);\n    event MinLockedAmountSet(uint256 indexed amount);\n}\n"
    },
    "contracts/libraries/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    uint256 currentAllowance = allowance(account, _msgSender());\n    require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n    unchecked {\n      _approve(account, _msgSender(), currentAllowance - amount);\n    }\n    _burn(account, amount);\n  }\n}\n"
    },
    "contracts/interfaces/IGovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.11;\n\ninterface IGovernanceToken {\n    function locked__of(address _addr) external view returns (uint256);\n\n    function locked__end(address _addr) external view returns (uint256);\n\n    function voting_power_unlock_time(uint256 _value, uint256 _unlock_time) external view returns (uint256);\n\n    function voting_power_locked_days(uint256 _value, uint256 _days) external view returns (uint256);\n\n    function deposit_for(address _addr, uint256 _value) external;\n\n    function create_lock(uint256 _value, uint256 _days) external;\n\n    function increase_amount(uint256 _value) external;\n\n    function increase_unlock_time(uint256 _days) external;\n\n    function withdraw() external;\n}\n"
    },
    "contracts/libraries/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"../interfaces/ERC20/IERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 internal _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override(IERC20, IERC20Metadata) returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "contracts/RequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Initializable.sol\";\nimport \"./libraries/ERC20Burnable.sol\";\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/Ownable.sol\";\n\n/**\n *  Governance token for requiem.finance\n *  - Flexible minting allowed for flexibility\n *  - Total supply cap for better control\n *  - Controllable minters with indivitual caps\n */\ncontract RequiemERC20Token is ERC20Permit, Ownable, ERC20Burnable {\n  uint256 public MAX_TOTAL_SUPPLY = 10_000_000_000 ether; // 10bn\n\n  mapping(address => uint256) public minters; // minter's address => minter's max cap\n  mapping(address => uint256) public minters_minted;\n\n  /* ========== EVENTS ========== */\n  event MinterUpdate(address indexed account, uint256 cap);\n  event MaxTotalSupplyUpdated(uint256 _newCap);\n\n  /* ========== Modifiers =============== */\n\n  modifier onlyMinter() {\n    require(minters[msg.sender] > 0, \"Only minter can interact\");\n    _;\n  }\n\n  constructor() ERC20(\"Requiem Token\", \"REQ\", 18) ERC20Permit(\"REQ\") {}\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function mint(address _recipient, uint256 _amount) public onlyMinter {\n    minters_minted[_msgSender()] += _amount;\n    require(\n      minters[_msgSender()] >= minters_minted[_msgSender()],\n      \"Minting amount exceeds minter cap\"\n    );\n    _mint(_recipient, _amount);\n  }\n\n  function _beforeTokenTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) internal override {\n    super._beforeTokenTransfer(_from, _to, _amount);\n    if (_from == address(0)) {\n      // When minting tokens\n      require(\n        totalSupply() + _amount <= MAX_TOTAL_SUPPLY,\n        \"Max total supply exceeded\"\n      );\n    }\n    if (_to == address(0)) {\n      // When burning tokens\n      require(\n        MAX_TOTAL_SUPPLY >= _amount,\n        \"Burn amount exceeds max total supply\"\n      );\n      MAX_TOTAL_SUPPLY -= _amount;\n    }\n  }\n\n  /* ========== OWNER FUNCTIONS ========== */\n\n  function setMinter(address _account, uint256 _minterCap) external onlyOwner {\n    require(_account != address(0), \"invalid address\");\n    require(\n      minters_minted[_account] <= _minterCap,\n      \"Minter already minted a larger amount than new cap\"\n    );\n    minters[_account] = _minterCap;\n    emit MinterUpdate(_account, _minterCap);\n  }\n\n  function resetMaxTotalSupply(uint256 _newCap) external onlyOwner {\n    require(_newCap >= totalSupply(), \"_newCap is below current total supply\");\n    MAX_TOTAL_SUPPLY = _newCap;\n    emit MaxTotalSupplyUpdated(_newCap);\n  }\n}\n"
    },
    "contracts/libraries/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}"
    },
    "contracts/libraries/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ERC20/IERC20Permit.sol\";\nimport \"./EIP712.sol\";\n\n// solhint-disable no-empty-blocks\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n  mapping(address => uint256) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\n      \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n   *\n   * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n   */\n  constructor(string memory name) EIP712(name, \"1\") {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    // solhint-disable-next-line not-rely-on-time\n    require(block.timestamp <= deadline, \"EXPIRED_PERMIT\");\n\n    uint256 nonce = _nonces[owner];\n    bytes32 structHash = keccak256(\n      abi.encode(_PERMIT_TYPEHASH, owner, spender, value, nonce, deadline)\n    );\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ecrecover(hash, v, r, s);\n    require((signer != address(0)) && (signer == owner), \"INVALID_SIGNATURE\");\n\n    _nonces[owner] = nonce + 1;\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n   */\n  function nonces(address owner) public view override returns (uint256) {\n    return _nonces[owner];\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n}\n"
    },
    "contracts/interfaces/ERC20/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/libraries/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _HASHED_NAME = keccak256(bytes(name));\n        _HASHED_VERSION = keccak256(bytes(version));\n        _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _getChainId(), address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));\n    }\n\n    function _getChainId() private view returns (uint256 chainId) {\n        // Silence state mutability warning without generating bytecode.\n        // See https://github.com/ethereum/solidity/issues/10090#issuecomment-741789128 and\n        // https://github.com/ethereum/solidity/issues/2691\n        this;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n}\n"
    },
    "contracts/sRequiemERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/ERC20Permit.sol\";\nimport \"./libraries/Manageable.sol\";\n\ncontract sRequiem is ERC20Permit, Manageable {\n  modifier onlyStakingContract() {\n    require(msg.sender == stakingContract, \"only staking\");\n    _;\n  }\n\n  address public stakingContract;\n  address public initializer;\n\n  event LogSupply(\n    uint256 indexed epoch,\n    uint256 timestamp,\n    uint256 _totalSupply\n  );\n  event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\n  event LogStakingContractUpdated(address stakingContract);\n\n  struct Rebase {\n    uint256 epoch;\n    uint256 rebase; // 18 decimals\n    uint256 totalStakedBefore;\n    uint256 totalStakedAfter;\n    uint256 amountRebased;\n    uint256 index;\n    uint256 blockNumberOccured;\n  }\n  Rebase[] public rebases;\n\n  uint256 public INDEX;\n\n  uint256 private constant MAX_UINT256 = ~uint256(0);\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**18;\n\n  // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\n  // Use the highest value that fits in a uint256 for max granularity.\n  uint256 private constant TOTAL_GONS =\n    MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\n\n  // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\n  uint256 private constant MAX_SUPPLY = ~uint128(0); // (2^128) - 1\n\n  uint256 private _gonsPerFragment;\n  mapping(address => uint256) private _gonBalances;\n\n  mapping(address => mapping(address => uint256)) private _allowedValue;\n\n  constructor() ERC20(\"Staked Requiem\", \"sREQ\", 18) ERC20Permit(\"sREQ\") {\n    initializer = msg.sender;\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\n    _gonsPerFragment = TOTAL_GONS / _totalSupply;\n  }\n\n  function initialize(address stakingContract_) external returns (bool) {\n    require(msg.sender == initializer);\n    require(stakingContract_ != address(0));\n    stakingContract = stakingContract_;\n    _gonBalances[stakingContract] = TOTAL_GONS;\n\n    emit Transfer(address(0x0), stakingContract, _totalSupply);\n    emit LogStakingContractUpdated(stakingContract_);\n\n    initializer = address(0);\n    return true;\n  }\n\n  function setIndex(uint256 _INDEX) external onlyManager returns (bool) {\n    require(INDEX == 0);\n    INDEX = gonsForBalance(_INDEX);\n    return true;\n  }\n\n  /**\n        @notice increases sREQT supply to increase staking balances relative to profit_\n        @param profit_ uint256\n        @return uint256\n     */\n  function rebase(uint256 profit_, uint256 epoch_)\n    public\n    onlyStakingContract\n    returns (uint256)\n  {\n    uint256 rebaseAmount;\n    uint256 circulatingSupply_ = circulatingSupply();\n\n    if (profit_ == 0) {\n      emit LogSupply(epoch_, block.timestamp, _totalSupply);\n      emit LogRebase(epoch_, 0, index());\n      return _totalSupply;\n    } else if (circulatingSupply_ > 0) {\n      rebaseAmount = (profit_ * _totalSupply) / circulatingSupply_;\n    } else {\n      rebaseAmount = profit_;\n    }\n\n    _totalSupply += rebaseAmount;\n\n    if (_totalSupply > MAX_SUPPLY) {\n      _totalSupply = MAX_SUPPLY;\n    }\n\n    _gonsPerFragment = TOTAL_GONS / _totalSupply;\n\n    _storeRebase(circulatingSupply_, profit_, epoch_);\n\n    return _totalSupply;\n  }\n\n  /**\n        @notice emits event with data about rebase\n        @param previousCirculating_ uint\n        @param profit_ uint\n        @param epoch_ uint\n        @return bool\n     */\n  function _storeRebase(\n    uint256 previousCirculating_,\n    uint256 profit_,\n    uint256 epoch_\n  ) internal returns (bool) {\n    uint256 rebasePercent = (profit_ * 1e18) / previousCirculating_;\n\n    rebases.push(\n      Rebase({\n        epoch: epoch_,\n        rebase: rebasePercent, // 18 decimals\n        totalStakedBefore: previousCirculating_,\n        totalStakedAfter: circulatingSupply(),\n        amountRebased: profit_,\n        index: index(),\n        blockNumberOccured: block.number\n      })\n    );\n\n    emit LogSupply(epoch_, block.timestamp, _totalSupply);\n    emit LogRebase(epoch_, rebasePercent, index());\n\n    return true;\n  }\n\n  function balanceOf(address who) public view override returns (uint256) {\n    return _gonBalances[who] / _gonsPerFragment;\n  }\n\n  function gonsForBalance(uint256 amount) public view returns (uint256) {\n    return amount * _gonsPerFragment;\n  }\n\n  function balanceForGons(uint256 gons) public view returns (uint256) {\n    return gons / _gonsPerFragment;\n  }\n\n  // Staking contract holds excess sREQT\n  function circulatingSupply() public view returns (uint256) {\n    return _totalSupply - balanceOf(stakingContract);\n  }\n\n  function index() public view returns (uint256) {\n    return balanceForGons(INDEX);\n  }\n\n  function transfer(address to, uint256 value) public override returns (bool) {\n    uint256 gonValue = value * _gonsPerFragment;\n    _gonBalances[msg.sender] -= gonValue;\n    _gonBalances[to] += gonValue;\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function allowance(address owner_, address spender)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return _allowedValue[owner_][spender];\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) public override returns (bool) {\n    _allowedValue[from][msg.sender] -= value;\n    emit Approval(from, msg.sender, _allowedValue[from][msg.sender]);\n\n    uint256 gonValue = gonsForBalance(value);\n    _gonBalances[from] = _gonBalances[from] - gonValue;\n    _gonBalances[to] = _gonBalances[to] + gonValue;\n    emit Transfer(from, to, value);\n\n    return true;\n  }\n\n  function approve(address spender, uint256 value)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  // What gets called in a permit\n  function _approve(\n    address owner,\n    address spender,\n    uint256 value\n  ) internal virtual override {\n    _allowedValue[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    override\n    returns (bool)\n  {\n    _allowedValue[msg.sender][spender] += addedValue;\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    override\n    returns (bool)\n  {\n    uint256 oldValue = _allowedValue[msg.sender][spender];\n    if (subtractedValue >= oldValue) {\n      _allowedValue[msg.sender][spender] = 0;\n    } else {\n      _allowedValue[msg.sender][spender] = oldValue - subtractedValue;\n    }\n    emit Approval(msg.sender, spender, _allowedValue[msg.sender][spender]);\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/Manageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../interfaces/IManageable.sol\";\n\ncontract Manageable is IManageable {\n\n    address internal _owner;\n    address internal _newOwner;\n\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        _owner = msg.sender;\n        emit OwnershipPushed( address(0), _owner );\n    }\n\n    function policy() public view override returns (address) {\n        return _owner;\n    }\n\n    modifier onlyPolicy() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    modifier onlyManager() {\n        require( _owner == msg.sender, \"Ownable: caller is not the owner\" );\n        _;\n    }\n\n    function renounceManagement() public virtual override onlyPolicy() {\n        emit OwnershipPushed( _owner, address(0) );\n        _owner = address(0);\n    }\n\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\n        require( newOwner_ != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipPushed( _owner, newOwner_ );\n        _newOwner = newOwner_;\n    }\n    \n    function pullManagement() public virtual override {\n        require( msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\n        emit OwnershipPulled( _owner, _newOwner );\n        _owner = _newOwner;\n    }\n}"
    },
    "contracts/interfaces/IManageable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n\ninterface IManageable {\n  function policy() external view returns (address);\n\n  function renounceManagement() external;\n  \n  function pushManagement( address newOwner_ ) external;\n  \n  function pullManagement() external;\n}"
    },
    "contracts/RedeemHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./libraries/Manageable.sol\";\nimport \"./interfaces/IBond.sol\";\n\ncontract RedeemHelper is Manageable {\n  address[] public bonds;\n\n  function redeemAll(address _recipient, bool _stake) external {\n    for (uint256 i = 0; i < bonds.length; i++) {\n      if (bonds[i] != address(0)) {\n        if (IBond(bonds[i]).pendingPayoutFor(_recipient) > 0) {\n          IBond(bonds[i]).redeem(_recipient, _stake);\n        }\n      }\n    }\n  }\n\n  function addBondContract(address _bond) external onlyPolicy {\n    require(_bond != address(0));\n    bonds.push(_bond);\n  }\n\n  function removeBondContract(uint256 _index) external onlyPolicy {\n    bonds[_index] = address(0);\n  }\n}\n"
    },
    "contracts/interfaces/IBond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IBond {\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\n}\n"
    },
    "contracts/test/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"../libraries/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {}\n\n    function mint(address to, uint256 value) public virtual {\n        _mint(to, value);\n    }\n\n    function burn(address from, uint256 value) public virtual {\n        _burn(from, value);\n    }\n}\n"
    },
    "contracts/test/MockGreq.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\n//import {IgREQ} from \"../interfaces/IgREQ.sol\";\nimport \"./MockERC20.sol\";\n\n// TODO fulfills IgREQ but is not inheriting because of dependency issues\ncontract MockGReq is MockERC20 {\n    /* ========== CONSTRUCTOR ========== */\n\n    uint256 public immutable index;\n\n    constructor(uint256 _initIndex) MockERC20(\"Governance REQ\", \"gREQ\", 18) {\n        index = _initIndex;\n    }\n\n    function migrate(address _staking, address _sReq) external {}\n\n    function balanceFrom(uint256 _amount) public view returns (uint256) {\n        return (_amount * index) / 10**decimals();\n    }\n\n    function balanceTo(uint256 _amount) public view returns (uint256) {\n        return (_amount * (10**decimals())) / index;\n    }\n}\n"
    },
    "contracts/FundDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Ownable.sol\";\nimport \"./libraries/Initializable.sol\";\nimport \"./interfaces/ERC20/IERC20.sol\";\nimport \"./libraries/ERC20.sol\";\nimport \"./libraries/Context.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport \"./interfaces/ERC20/IRewardToken.sol\";\n\ncontract FundDistributor is Ownable, Initializable, Context {\n  using SafeERC20 for IRewardToken;\n\n  IRewardToken public reward;\n  uint256 public missingDecimals;\n\n  // CONTRACTS\n  mapping(address => bool) public requesters;\n\n  /* ========== MODIFIER ========== */\n\n  modifier onlyRequester() {\n    require(requesters[_msgSender()], \"Only pool can request transfer\");\n    _;\n  }\n\n  function initialize(address _reward) external initializer {\n    reward = IRewardToken(_reward);\n    missingDecimals = 18 - ERC20(_reward).decimals();\n  }\n\n  /* ========== MUTATIVE ====================== */\n\n  function distributeTo(address _receiver, uint256 _amount)\n    public\n    onlyRequester\n  {\n    require(_receiver != address(0), \"Invalid address\");\n    if (_amount > 0) {\n      reward.mint(_receiver, _amount / (10**missingDecimals));\n    }\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function addRequester(address _requester) external onlyOwner {\n    require(!requesters[_requester], \"requester existed\");\n    requesters[_requester] = true;\n    emit RequesterAdded(_requester);\n  }\n\n  function removeRequester(address _requester) external onlyOwner {\n    require(requesters[_requester], \"requester not found\");\n    delete requesters[_requester];\n    emit RequesterRemoved(_requester);\n  }\n\n  /* ========== EVENTS ========================= */\n\n  event RequesterAdded(address indexed requester);\n  event RequesterRemoved(address indexed requester);\n  event FundRequested(uint256 indexed amount);\n}\n"
    },
    "contracts/interfaces/ERC20/IRewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IRewardToken is IERC20 {\n    function mint(address _recipient, uint256 _amount) external;\n}\n"
    },
    "contracts/BondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.11;\n\nimport \"./libraries/types/NoteKeeper.sol\";\n\nimport \"./libraries/SafeERC20.sol\";\n\nimport \"./interfaces/ERC20/IERC20Metadata.sol\";\nimport \"./interfaces/IBondDepository.sol\";\n\n// solhint-disable  max-line-length\n\n/// @title Requiem Bond Depository\n/// @author Zeus, Indigo\n/// Review by: JeffX\n\ncontract BondDepository is IBondDepository, NoteKeeper {\n    /* ======== DEPENDENCIES ======== */\n\n    using SafeERC20 for IERC20;\n\n    /* ======== EVENTS ======== */\n\n    event CreateMarket(uint256 indexed id, address indexed baseToken, address indexed quoteToken, uint256 initialPrice);\n    event CloseMarket(uint256 indexed id);\n    event Bond(uint256 indexed id, uint256 amount, uint256 price);\n    event Tuned(uint256 indexed id, uint64 oldControlVariable, uint64 newControlVariable);\n\n    /* ======== STATE VARIABLES ======== */\n\n    // Storage\n    Market[] public markets; // persistent market data\n    Terms[] public terms; // deposit construction data\n    Metadata[] public metadata; // extraneous market data\n    mapping(uint256 => Adjustment) public adjustments; // control variable changes\n\n    // Queries\n    mapping(address => uint256[]) public marketsForQuote; // market IDs for quote token\n\n    /* ======== CONSTRUCTOR ======== */\n\n    constructor(\n        IAuthority _authority,\n        IERC20 _req,\n        IgREQ _greq,\n        IStaking _staking,\n        ITreasury _treasury\n    ) NoteKeeper(_authority, _req, _greq, _staking, _treasury) {\n        // save gas for users by bulk approving stake() transactions\n        _req.approve(address(_staking), 1e45);\n    }\n\n    /* ======== DEPOSIT ======== */\n\n    /**\n     * @notice             deposit quote tokens in exchange for a bond from a specified market\n     * @param _id          the ID of the market\n     * @param _amount      the amount of quote token to spend\n     * @param _maxPrice    the maximum price at which to buy\n     * @param _user        the recipient of the payout\n     * @param _referral    the front end operator address\n     * @return payout_     the amount of gREQ due\n     * @return expiry_     the timestamp at which payout is redeemable\n     * @return index_      the user index of the Note (used to redeem or query information)\n     */\n    function deposit(\n        uint256 _id,\n        uint256 _amount,\n        uint256 _maxPrice,\n        address _user,\n        address _referral\n    )\n        external\n        override\n        returns (\n            uint256 payout_,\n            uint256 expiry_,\n            uint256 index_\n        )\n    {\n        Market storage market = markets[_id];\n        Terms memory term = terms[_id];\n        uint48 currentTime = uint48(block.timestamp);\n\n        // Markets end at a defined timestamp\n        // |-------------------------------------| t\n        require(currentTime < term.conclusion, \"Depository: market concluded\");\n\n        // Debt and the control variable decay over time\n        _decay(_id, currentTime);\n\n        // Users input a maximum price, which protects them from price changes after\n        // entering the mempool. max price is a slippage mitigation measure\n        uint256 price = _marketPrice(_id);\n        require(price <= _maxPrice, \"Depository: more than max price\");\n\n        /**\n         * payout for the deposit = amount / price\n         *\n         * where\n         * payout = REQ out\n         * amount = quote tokens in\n         * price = quote tokens : req (i.e. 42069 DAI : REQ)\n         *\n         * 1e18 = REQ decimals + price decimals\n         */\n        payout_ = ((_amount * (2 * req.decimals())) / price) / (10**metadata[_id].quoteDecimals);\n\n        // markets have a max payout amount, capping size because deposits\n        // do not experience slippage. max payout is recalculated upon tuning\n        require(payout_ <= market.maxPayout, \"Depository: max size exceeded\");\n\n        /*\n         * each market is initialized with a capacity\n         *\n         * this is either the number of REQ that the market can sell\n         * (if capacity in quote is false),\n         *\n         * or the number of quote tokens that the market can buy\n         * (if capacity in quote is true)\n         */\n        market.capacity -= market.capacityInQuote ? _amount : payout_;\n\n        /**\n         * bonds mature with a cliff at a set timestamp\n         * prior to the expiry timestamp, no payout tokens are accessible to the user\n         * after the expiry timestamp, the entire payout can be redeemed\n         *\n         * there are two types of bonds: fixed-term and fixed-expiration\n         *\n         * fixed-term bonds mature in a set amount of time from deposit\n         * i.e. term = 1 week. when alice deposits on day 1, her bond\n         * expires on day 8. when bob deposits on day 2, his bond expires day 9.\n         *\n         * fixed-expiration bonds mature at a set timestamp\n         * i.e. expiration = day 10. when alice deposits on day 1, her term\n         * is 9 days. when bob deposits on day 2, his term is 8 days.\n         */\n        expiry_ = term.fixedTerm ? term.vesting + currentTime : term.vesting;\n\n        // markets keep track of how many quote tokens have been\n        // purchased, and how much REQ has been sold\n        market.purchased += _amount;\n        market.sold += uint64(payout_);\n\n        // incrementing total debt raises the price of the next bond\n        market.totalDebt += uint64(payout_);\n\n        emit Bond(_id, _amount, price);\n\n        /**\n         * user data is stored as Notes. these are isolated array entries\n         * storing the amount due, the time created, the time when payout\n         * is redeemable, the time when payout was redeemed, and the ID\n         * of the market deposited into\n         */\n        index_ = addNote(_user, payout_, uint48(expiry_), uint48(_id), _referral);\n\n        // transfer payment to treasury\n        market.quoteToken.safeTransferFrom(msg.sender, address(treasury), _amount);\n\n        // if max debt is breached, the market is closed\n        // this a circuit breaker\n        if (term.maxDebt < market.totalDebt) {\n            market.capacity = 0;\n            emit CloseMarket(_id);\n        } else {\n            // if market will continue, the control variable is tuned to hit targets on time\n            _tune(_id, currentTime);\n        }\n    }\n\n    /**\n     * @notice             decay debt, and adjust control variable if there is an active change\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _decay(uint256 _id, uint48 _time) internal {\n        // Debt decay\n\n        /*\n         * Debt is a time-decayed sum of tokens spent in a market\n         * Debt is added when deposits occur and removed over time\n         * |\n         * |    debt falls with\n         * |   / \\  inactivity       / \\\n         * | /     \\              /\\/    \\\n         * |         \\           /         \\\n         * |           \\      /\\/            \\\n         * |             \\  /  and rises       \\\n         * |                with deposits\n         * |\n         * |------------------------------------| t\n         */\n        markets[_id].totalDebt -= debtDecay(_id);\n        metadata[_id].lastDecay = _time;\n\n        // Control variable decay\n\n        // The bond control variable is continually tuned. When it is lowered (which\n        // lowers the market price), the change is carried out smoothly over time.\n        if (adjustments[_id].active) {\n            Adjustment storage adjustment = adjustments[_id];\n\n            (uint64 adjustBy, uint48 secondsSince, bool stillActive) = _controlDecay(_id);\n            terms[_id].controlVariable -= adjustBy;\n\n            if (stillActive) {\n                adjustment.change -= adjustBy;\n                adjustment.timeToAdjusted -= secondsSince;\n                adjustment.lastAdjustment = _time;\n            } else {\n                adjustment.active = false;\n            }\n        }\n    }\n\n    /**\n     * @notice             auto-adjust control variable to hit capacity/spend target\n     * @param _id          ID of market\n     * @param _time        uint48 timestamp (saves gas when passed in)\n     */\n    function _tune(uint256 _id, uint48 _time) internal {\n        Metadata memory meta = metadata[_id];\n\n        if (_time >= meta.lastTune + meta.tuneInterval) {\n            Market memory market = markets[_id];\n\n            // compute seconds remaining until market will conclude\n            uint256 timeRemaining = terms[_id].conclusion - _time;\n            uint256 price = _marketPrice(_id);\n\n            // standardize capacity into an base token amount\n            // req decimals + price decimals\n            uint256 capacity = market.capacityInQuote\n                ? ((market.capacity * (10**(2 * req.decimals()))) / price) / (10**meta.quoteDecimals)\n                : market.capacity;\n\n            /**\n             * calculate the correct payout to complete on time assuming each bond\n             * will be max size in the desired deposit interval for the remaining time\n             *\n             * i.e. market has 10 days remaining. deposit interval is 1 day. capacity\n             * is 10,000 REQ. max payout would be 1,000 REQ (10,000 * 1 / 10).\n             */\n            markets[_id].maxPayout = uint64((capacity * meta.depositInterval) / timeRemaining);\n\n            // calculate the ideal total debt to satisfy capacity in the remaining time\n            uint256 targetDebt = (capacity * meta.length) / timeRemaining;\n\n            // derive a new control variable from the target debt and current supply\n            uint64 newControlVariable = uint64((price * treasury.baseSupply()) / targetDebt);\n\n            emit Tuned(_id, terms[_id].controlVariable, newControlVariable);\n\n            if (newControlVariable >= terms[_id].controlVariable) {\n                terms[_id].controlVariable = newControlVariable;\n            } else {\n                // if decrease, control variable change will be carried out over the tune interval\n                // this is because price will be lowered\n                uint64 change = terms[_id].controlVariable - newControlVariable;\n                adjustments[_id] = Adjustment(change, _time, meta.tuneInterval, true);\n            }\n            metadata[_id].lastTune = _time;\n        }\n    }\n\n    /* ======== CREATE ======== */\n\n    /**\n     * @notice             creates a new market type\n     * @dev                current price should be in 9 decimals.\n     * @param _quoteToken  token used to deposit\n     * @param _market      [capacity (in REQ or quote), initial price / REQ (18 decimals), debt buffer (3 decimals)]\n     * @param _booleans    [capacity in quote, fixed term]\n     * @param _terms       [vesting length (if fixed term) or vested timestamp, conclusion timestamp]\n     * @param _intervals   [deposit interval (seconds), tune interval (seconds)]\n     * @return id_         ID of new bond market\n     */\n    function create(\n        IERC20 _quoteToken,\n        uint256[3] memory _market,\n        bool[2] memory _booleans,\n        uint256[2] memory _terms,\n        uint32[2] memory _intervals\n    ) external override onlyPolicy returns (uint256 id_) {\n        // the length of the program, in seconds\n        uint256 secondsToConclusion = _terms[1] - block.timestamp;\n\n        // the decimal count of the quote token\n        uint256 decimals = IERC20Metadata(address(_quoteToken)).decimals();\n\n        /*\n         * initial target debt is equal to capacity (this is the amount of debt\n         * that will decay over in the length of the program if price remains the same).\n         * it is converted into base token terms if passed in in quote token terms.\n         *\n         * 1e18 = req decimals (x) + initial price decimals (9)\n         */\n        uint64 targetDebt = uint64(_booleans[0] ? ((_market[0] * (10**(2 * req.decimals()))) / _market[1]) / 10**decimals : _market[0]);\n\n        /*\n         * max payout is the amount of capacity that should be utilized in a deposit\n         * interval. for example, if capacity is 1,000 REQ, there are 10 days to conclusion,\n         * and the preferred deposit interval is 1 day, max payout would be 100 REQ.\n         */\n        uint64 maxPayout = uint64((targetDebt * _intervals[0]) / secondsToConclusion);\n\n        /*\n         * max debt serves as a circuit breaker for the market. let's say the quote\n         * token is a stablecoin, and that stablecoin depegs. without max debt, the\n         * market would continue to buy until it runs out of capacity. this is\n         * configurable with a 3 decimal buffer (1000 = 1% above initial price).\n         * note that its likely advisable to keep this buffer wide.\n         * note that the buffer is above 100%. i.e. 10% buffer = initial debt * 1.1\n         */\n        uint256 maxDebt = targetDebt + ((targetDebt * _market[2]) / 1e5); // 1e5 = 100,000. 10,000 / 100,000 = 10%.\n\n        /*\n         * the control variable is set so that initial price equals the desired\n         * initial price. the control variable is the ultimate determinant of price,\n         * so we compute this last.\n         *\n         * price = control variable * debt ratio\n         * debt ratio = total debt / supply\n         * therefore, control variable = price / debt ratio\n         */\n        uint256 controlVariable = (_market[1] * treasury.baseSupply()) / targetDebt;\n\n        // depositing into, or getting info for, the created market uses this ID\n        id_ = markets.length;\n\n        markets.push(\n            Market({\n                quoteToken: _quoteToken,\n                capacityInQuote: _booleans[0],\n                capacity: _market[0],\n                totalDebt: targetDebt,\n                maxPayout: maxPayout,\n                purchased: 0,\n                sold: 0\n            })\n        );\n\n        terms.push(\n            Terms({\n                fixedTerm: _booleans[1],\n                controlVariable: uint64(controlVariable),\n                vesting: uint48(_terms[0]),\n                conclusion: uint48(_terms[1]),\n                maxDebt: uint64(maxDebt)\n            })\n        );\n\n        metadata.push(\n            Metadata({\n                lastTune: uint48(block.timestamp),\n                lastDecay: uint48(block.timestamp),\n                length: uint48(secondsToConclusion),\n                depositInterval: _intervals[0],\n                tuneInterval: _intervals[1],\n                quoteDecimals: uint8(decimals)\n            })\n        );\n\n        marketsForQuote[address(_quoteToken)].push(id_);\n\n        emit CreateMarket(id_, address(req), address(_quoteToken), _market[1]);\n    }\n\n    /**\n     * @notice             disable existing market\n     * @param _id          ID of market to close\n     */\n    function close(uint256 _id) external override onlyPolicy {\n        terms[_id].conclusion = uint48(block.timestamp);\n        markets[_id].capacity = 0;\n        emit CloseMarket(_id);\n    }\n\n    /* ======== EXTERNAL VIEW ======== */\n\n    /**\n     * @notice             calculate current market price of quote token in base token\n     * @dev                accounts for debt and control variable decay since last deposit (vs _marketPrice())\n     * @param _id          ID of market\n     * @return             price for market in REQ decimals\n     *\n     * price is derived from the equation\n     *\n     * p = cv * dr\n     *\n     * where\n     * p = price\n     * cv = control variable\n     * dr = debt ratio\n     *\n     * dr = d / s\n     *\n     * where\n     * d = debt\n     * s = supply of token at market creation\n     *\n     * d -= ( d * (dt / l) )\n     *\n     * where\n     * dt = change in time\n     * l = length of program\n     */\n    function marketPrice(uint256 _id) public view override returns (uint256) {\n        return (currentControlVariable(_id) * debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice             payout due for amount of quote tokens\n     * @dev                accounts for debt and control variable decay so it is up to date\n     * @param _amount      amount of quote tokens to spend\n     * @param _id          ID of market\n     * @return             amount of REQ to be paid in REQ decimals\n     *\n     * @dev 1e18 = req decimals (9) + market price decimals (9)\n     */\n    function payoutFor(uint256 _amount, uint256 _id) external view override returns (uint256) {\n        Metadata memory meta = metadata[_id];\n        return (_amount * 10**(2 * req.decimals())) / marketPrice(_id) / 10**meta.quoteDecimals;\n    }\n\n    /**\n     * @notice             calculate current ratio of debt to supply\n     * @dev                uses current debt, which accounts for debt decay since last deposit (vs _debtRatio())\n     * @param _id          ID of market\n     * @return             debt ratio for market in quote decimals\n     */\n    function debtRatio(uint256 _id) public view override returns (uint256) {\n        return (currentDebt(_id) * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice             calculate debt factoring in decay\n     * @dev                accounts for debt decay since last deposit\n     * @param _id          ID of market\n     * @return             current debt for market in REQ decimals\n     */\n    function currentDebt(uint256 _id) public view override returns (uint256) {\n        return markets[_id].totalDebt - debtDecay(_id);\n    }\n\n    /**\n     * @notice             amount of debt to decay from total debt for market ID\n     * @param _id          ID of market\n     * @return             amount of debt to decay\n     */\n    function debtDecay(uint256 _id) public view override returns (uint64) {\n        Metadata memory meta = metadata[_id];\n\n        uint256 secondsSince = block.timestamp - meta.lastDecay;\n\n        return uint64((markets[_id].totalDebt * secondsSince) / meta.length);\n    }\n\n    /**\n     * @notice             up to date control variable\n     * @dev                accounts for control variable adjustment\n     * @param _id          ID of market\n     * @return             control variable for market in REQ decimals\n     */\n    function currentControlVariable(uint256 _id) public view returns (uint256) {\n        (uint64 decay, , ) = _controlDecay(_id);\n        return terms[_id].controlVariable - decay;\n    }\n\n    /**\n     * @notice             is a given market accepting deposits\n     * @param _id          ID of market\n     */\n    function isLive(uint256 _id) public view override returns (bool) {\n        return (markets[_id].capacity != 0 && terms[_id].conclusion > block.timestamp);\n    }\n\n    /**\n     * @notice returns an array of all active market IDs\n     */\n    function liveMarkets() external view override returns (uint256[] memory) {\n        uint256 num;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n        for (uint256 i = 0; i < markets.length; i++) {\n            if (isLive(i)) {\n                ids[nonce] = i;\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /**\n     * @notice             returns an array of all active market IDs for a given quote token\n     * @param _token       quote token to check for\n     */\n    function liveMarketsFor(address _token) external view override returns (uint256[] memory) {\n        uint256[] memory mkts = marketsForQuote[_token];\n        uint256 num;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) num++;\n        }\n\n        uint256[] memory ids = new uint256[](num);\n        uint256 nonce;\n\n        for (uint256 i = 0; i < mkts.length; i++) {\n            if (isLive(mkts[i])) {\n                ids[nonce] = mkts[i];\n                nonce++;\n            }\n        }\n        return ids;\n    }\n\n    /* ======== INTERNAL VIEW ======== */\n\n    /**\n     * @notice                  calculate current market price of quote token in base token\n     * @dev                     see marketPrice() for explanation of price computation\n     * @dev                     uses info from storage because data has been updated before call (vs marketPrice())\n     * @param _id               market ID\n     * @return                  price for market in REQ decimals\n     */\n    function _marketPrice(uint256 _id) internal view returns (uint256) {\n        return (terms[_id].controlVariable * _debtRatio(_id)) / (10**metadata[_id].quoteDecimals);\n    }\n\n    /**\n     * @notice                  calculate debt factoring in decay\n     * @dev                     uses info from storage because data has been updated before call (vs debtRatio())\n     * @param _id               market ID\n     * @return                  current debt for market in quote decimals\n     */\n    function _debtRatio(uint256 _id) internal view returns (uint256) {\n        return (markets[_id].totalDebt * (10**metadata[_id].quoteDecimals)) / treasury.baseSupply();\n    }\n\n    /**\n     * @notice                  amount to decay control variable by\n     * @param _id               ID of market\n     * @return decay_           change in control variable\n     * @return secondsSince_    seconds since last change in control variable\n     * @return active_          whether or not change remains active\n     */\n    function _controlDecay(uint256 _id)\n        internal\n        view\n        returns (\n            uint64 decay_,\n            uint48 secondsSince_,\n            bool active_\n        )\n    {\n        Adjustment memory info = adjustments[_id];\n        if (!info.active) return (0, 0, false);\n\n        secondsSince_ = uint48(block.timestamp) - info.lastAdjustment;\n\n        active_ = secondsSince_ < info.timeToAdjusted;\n        decay_ = active_ ? (info.change * secondsSince_) / info.timeToAdjusted : info.change;\n    }\n}\n"
    },
    "contracts/libraries/types/NoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./FrontEndRewarder.sol\";\n\nimport \"../../interfaces/IgREQ.sol\";\nimport \"../../interfaces/IStaking.sol\";\nimport \"../../interfaces/ITreasury.sol\";\nimport \"../../interfaces/INoteKeeper.sol\";\n\n// solhint-disable max-line-length\n\nabstract contract NoteKeeper is INoteKeeper, FrontEndRewarder {\n    mapping(address => Note[]) public notes; // user deposit data\n    mapping(address => mapping(uint256 => address)) private noteTransfers; // change note ownership\n\n    IgREQ internal immutable gREQ;\n    IStaking internal immutable staking;\n    ITreasury internal treasury;\n\n    constructor(\n        IAuthority _authority,\n        IERC20 _req,\n        IgREQ _greq,\n        IStaking _staking,\n        ITreasury _treasury\n    ) FrontEndRewarder(_authority, _req) {\n        gREQ = _greq;\n        staking = _staking;\n        treasury = _treasury;\n    }\n\n    // if treasury address changes on authority, update it\n    function updateTreasury() external {\n        require(\n            msg.sender == authority.governor() ||\n                msg.sender == authority.guardian() ||\n                msg.sender == authority.policy(),\n            \"Only authorized\"\n        );\n        treasury = ITreasury(authority.vault());\n    }\n\n    /* ========== ADD ========== */\n\n    /**\n     * @notice             adds a new Note for a user, stores the front end & DAO rewards, and mints & stakes payout & rewards\n     * @param _user        the user that owns the Note\n     * @param _payout      the amount of REQ due to the user\n     * @param _expiry      the timestamp when the Note is redeemable\n     * @param _marketID    the ID of the market deposited into\n     * @return index_      the index of the Note in the user's array\n     */\n    function addNote(\n        address _user,\n        uint256 _payout,\n        uint48 _expiry,\n        uint48 _marketID,\n        address _referral\n    ) internal returns (uint256 index_) {\n        // the index of the note is the next in the user's array\n        index_ = notes[_user].length;\n\n        // the new note is pushed to the user's array\n        notes[_user].push(\n            Note({\n                payout: gREQ.balanceTo(_payout),\n                created: uint48(block.timestamp),\n                matured: _expiry,\n                redeemed: 0,\n                marketID: _marketID\n            })\n        );\n\n        // front end operators can earn rewards by referring users\n        uint256 rewards = _giveRewards(_payout, _referral);\n\n        // mint and stake payout\n        treasury.mint(address(this), _payout + rewards);\n\n        // note that only the payout gets staked (front end rewards are in REQ)\n        staking.stake(address(this), _payout, false, true);\n    }\n\n    /* ========== REDEEM ========== */\n\n    /**\n     * @notice             redeem notes for user\n     * @param _user        the user to redeem for\n     * @param _indexes     the note indexes to redeem\n     * @param _sendgREQ    send payout as gREQ or sREQ\n     * @return payout_     sum of payout sent, in gREQ\n     */\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgREQ\n    ) public override returns (uint256 payout_) {\n        uint48 time = uint48(block.timestamp);\n\n        for (uint256 i = 0; i < _indexes.length; i++) {\n            (uint256 pay, bool matured) = pendingFor(_user, _indexes[i]);\n\n            if (matured) {\n                notes[_user][_indexes[i]].redeemed = time; // mark as redeemed\n                payout_ += pay;\n            }\n        }\n\n        if (_sendgREQ) {\n            gREQ.transfer(_user, payout_); // send payout as gREQ\n        } else {\n            staking.unwrap(_user, payout_); // unwrap and send payout as sREQ\n        }\n    }\n\n    /**\n     * @notice             redeem all redeemable markets for user\n     * @dev                if possible, query indexesFor() off-chain and input in redeem() to save gas\n     * @param _user        user to redeem all notes for\n     * @param _sendgREQ    send payout as gREQ or sREQ\n     * @return             sum of payout sent, in gREQ\n     */\n    function redeemAll(address _user, bool _sendgREQ) external override returns (uint256) {\n        return redeem(_user, indexesFor(_user), _sendgREQ);\n    }\n\n    /* ========== TRANSFER ========== */\n\n    /**\n     * @notice             approve an address to transfer a note\n     * @param _to          address to approve note transfer for\n     * @param _index       index of note to approve transfer for\n     */\n    function pushNote(address _to, uint256 _index) external override {\n        require(notes[msg.sender][_index].created != 0, \"Depository: note not found\");\n        noteTransfers[msg.sender][_index] = _to;\n    }\n\n    /**\n     * @notice             transfer a note that has been approved by an address\n     * @param _from        the address that approved the note transfer\n     * @param _index       the index of the note to transfer (in the sender's array)\n     */\n    function pullNote(address _from, uint256 _index) external override returns (uint256 newIndex_) {\n        require(noteTransfers[_from][_index] == msg.sender, \"Depository: transfer not found\");\n        require(notes[_from][_index].redeemed == 0, \"Depository: note redeemed\");\n\n        newIndex_ = notes[msg.sender].length;\n        notes[msg.sender].push(notes[_from][_index]);\n\n        delete notes[_from][_index];\n    }\n\n    /* ========== VIEW ========== */\n\n    // Note info\n\n    /**\n     * @notice             all pending notes for user\n     * @param _user        the user to query notes for\n     * @return             the pending notes for the user\n     */\n    function indexesFor(address _user) public view override returns (uint256[] memory) {\n        Note[] memory info = notes[_user];\n\n        uint256 length;\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) length++;\n        }\n\n        uint256[] memory indexes = new uint256[](length);\n        uint256 position;\n\n        for (uint256 i = 0; i < info.length; i++) {\n            if (info[i].redeemed == 0 && info[i].payout != 0) {\n                indexes[position] = i;\n                position++;\n            }\n        }\n\n        return indexes;\n    }\n\n    /**\n     * @notice             calculate amount available for claim for a single note\n     * @param _user        the user that the note belongs to\n     * @param _index       the index of the note in the user's array\n     * @return payout_     the payout due, in gREQ\n     * @return matured_    if the payout can be redeemed\n     */\n    function pendingFor(address _user, uint256 _index) public view override returns (uint256 payout_, bool matured_) {\n        Note memory note = notes[_user][_index];\n\n        payout_ = note.payout;\n        matured_ = note.redeemed == 0 && note.matured <= block.timestamp && note.payout != 0;\n    }\n}\n"
    },
    "contracts/interfaces/IBondDepository.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./ERC20/IERC20.sol\";\n\ninterface IBondDepository {\n\n  // Info about each type of market\n  struct Market {\n    uint256 capacity; // capacity remaining\n    IERC20 quoteToken; // token to accept as payment\n    bool capacityInQuote; // capacity limit is in payment token (true) or in REQ (false, default)\n    uint64 totalDebt; // total debt from market\n    uint64 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\n    uint64 sold; // base tokens out\n    uint256 purchased; // quote tokens in\n  }\n\n  // Info for creating new markets\n  struct Terms {\n    bool fixedTerm; // fixed term or fixed expiration\n    uint64 controlVariable; // scaling variable for price\n    uint48 vesting; // length of time from deposit to maturity if fixed-term\n    uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\n    uint64 maxDebt; // 9 decimal debt maximum in REQ\n  }\n\n  // Additional info about market.\n  struct Metadata {\n    uint48 lastTune; // last timestamp when control variable was tuned\n    uint48 lastDecay; // last timestamp when market was created and debt was decayed\n    uint48 length; // time from creation to conclusion. used as speed to decay debt.\n    uint48 depositInterval; // target frequency of deposits\n    uint48 tuneInterval; // frequency of tuning\n    uint8 quoteDecimals; // decimals of quote token\n  }\n\n  // Control variable adjustment data\n  struct Adjustment {\n    uint64 change;\n    uint48 lastAdjustment;\n    uint48 timeToAdjusted;\n    bool active;\n  }\n\n\n  /**\n   * @notice deposit market\n   * @param _bid uint256\n   * @param _amount uint256\n   * @param _maxPrice uint256\n   * @param _user address\n   * @param _referral address\n   * @return payout_ uint256\n   * @return expiry_ uint256\n   * @return index_ uint256\n   */\n  function deposit(\n    uint256 _bid,\n    uint256 _amount,\n    uint256 _maxPrice,\n    address _user,\n    address _referral\n  ) external returns (\n    uint256 payout_, \n    uint256 expiry_,\n    uint256 index_\n  );\n\n  function create (\n    IERC20 _quoteToken, // token used to deposit\n    uint256[3] memory _market, // [capacity, initial price]\n    bool[2] memory _booleans, // [capacity in quote, fixed term]\n    uint256[2] memory _terms, // [vesting, conclusion]\n    uint32[2] memory _intervals // [deposit interval, tune interval]\n  ) external returns (uint256 id_);\n  function close(uint256 _id) external;\n\n  function isLive(uint256 _bid) external view returns (bool);\n  function liveMarkets() external view returns (uint256[] memory);\n  function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\n  function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\n  function marketPrice(uint256 _bid) external view returns (uint256);\n  function currentDebt(uint256 _bid) external view returns (uint256);\n  function debtRatio(uint256 _bid) external view returns (uint256);\n  function debtDecay(uint256 _bid) external view returns (uint64);\n}"
    },
    "contracts/libraries/types/FrontEndRewarder.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.10;\n\nimport \"./AccessControlled.sol\";\nimport \"../../interfaces/ERC20/IERC20.sol\";\n\nabstract contract FrontEndRewarder is AccessControlled {\n    /* ========= STATE VARIABLES ========== */\n\n    uint256 public daoReward; // % reward for dao (3 decimals: 100 = 1%)\n    uint256 public refReward; // % reward for referrer (3 decimals: 100 = 1%)\n    mapping(address => uint256) public rewards; // front end operator rewards\n    mapping(address => bool) public whitelisted; // whitelisted status for operators\n\n    IERC20 internal immutable req; // reward token\n\n    constructor(IAuthority _authority, IERC20 _req) AccessControlled(_authority) {\n        req = _req;\n    }\n\n    /* ========= EXTERNAL FUNCTIONS ========== */\n\n    // pay reward to front end operator\n    function getReward() external {\n        uint256 reward = rewards[msg.sender];\n\n        rewards[msg.sender] = 0;\n        req.transfer(msg.sender, reward);\n    }\n\n    /* ========= INTERNAL ========== */\n\n    /**\n     * @notice add new market payout to user data\n     */\n    function _giveRewards(uint256 _payout, address _referral) internal returns (uint256) {\n        // first we calculate rewards paid to the DAO and to the front end operator (referrer)\n        uint256 toDAO = (_payout * daoReward) / 1e4;\n        uint256 toRef = (_payout * refReward) / 1e4;\n\n        // and store them in our rewards mapping\n        if (whitelisted[_referral]) {\n            rewards[_referral] += toRef;\n            rewards[authority.guardian()] += toDAO;\n        } else {\n            // the DAO receives both rewards if referrer is not whitelisted\n            rewards[authority.guardian()] += toDAO + toRef;\n        }\n        return toDAO + toRef;\n    }\n\n    /**\n     * @notice set rewards for front end operators and DAO\n     */\n    function setRewards(uint256 _toFrontEnd, uint256 _toDAO) external onlyGovernor {\n        refReward = _toFrontEnd;\n        daoReward = _toDAO;\n    }\n\n    /**\n     * @notice add or remove addresses from the reward whitelist\n     */\n    function whitelist(address _operator) external onlyPolicy {\n        whitelisted[_operator] = !whitelisted[_operator];\n    }\n}\n"
    },
    "contracts/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IStaking {\n    function stake(\n        address _to,\n        uint256 _amount,\n        bool _rebasing,\n        bool _claim\n    ) external returns (uint256);\n\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\n\n    function forfeit() external returns (uint256);\n\n    function toggleLock() external;\n\n    function unstake(\n        address _to,\n        uint256 _amount,\n        bool _trigger,\n        bool _rebasing\n    ) external returns (uint256);\n\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\n\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\n\n    function rebase() external;\n\n    function index() external view returns (uint256);\n\n    function contractBalance() external view returns (uint256);\n\n    function totalStaked() external view returns (uint256);\n\n    function supplyInWarmup() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/INoteKeeper.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.7.5;\n\ninterface INoteKeeper {\n    // Info for market note\n    struct Note {\n        uint256 payout; // gREQ remaining to be paid\n        uint48 created; // time market was created\n        uint48 matured; // timestamp when market is matured\n        uint48 redeemed; // time market was redeemed\n        uint48 marketID; // market ID of deposit. uint48 to avoid adding a slot.\n    }\n\n    function redeem(\n        address _user,\n        uint256[] memory _indexes,\n        bool _sendgREQ\n    ) external returns (uint256);\n\n    function redeemAll(address _user, bool _sendgREQ) external returns (uint256);\n\n    function pushNote(address to, uint256 index) external;\n\n    function pullNote(address from, uint256 index) external returns (uint256 newIndex_);\n\n    function indexesFor(address _user) external view returns (uint256[] memory);\n\n    function pendingFor(address _user, uint256 _index) external view returns (uint256 payout_, bool matured_);\n}\n"
    },
    "contracts/libraries/VaultOwned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"./Ownable.sol\";\n\ncontract VaultOwned is Ownable {\n    \n  address internal _vault;\n\n  function setVault( address vault_ ) external onlyOwner() returns ( bool ) {\n    _vault = vault_;\n\n    return true;\n  }\n\n  function vault() public view returns (address) {\n    return _vault;\n  }\n\n  modifier onlyVault() {\n    require( _vault == msg.sender, \"VaultOwned: caller is not the Vault\" );\n    _;\n  }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}